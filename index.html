<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cricket Player Dashboard</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #0056b3;
            text-align: center;
        }
        #loading {
            text-align: center;
            font-size: 18px;
            margin: 30px 0;
            color: #666;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #0056b3;
            color: white;
            position: sticky;
            top: 0;
        }
        tr:hover {
            background-color: #f1f8ff;
        }
        .error {
            color: red;
            text-align: center;
            padding: 20px;
            background-color: #ffeeee;
            border-radius: 5px;
            margin: 20px 0;
        }
        .refresh-btn {
            background-color: #0056b3;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: block;
            margin: 20px auto;
        }
        .refresh-btn:hover {
            background-color: #003d7a;
        }
        .stats-info {
            text-align: center;
            margin-bottom: 20px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Cricket Player Dashboard</h1>
        <div class="stats-info">Last updated: <span id="update-time"></span></div>
        <div id="loading">Loading player data...</div>
        <div id="error-container"></div>
        <div id="player-table-container"></div>
        <button class="refresh-btn" onclick="refreshData()">Refresh Data</button>
    </div>

    <script>
        // Constants
        const API_KEY = "282bffef-9065-43b3-91f0-df54dec227fd";
        const IPL_2025_SERIES_ID = "d5a498c8-7596-4b93-8ab0-e0efc3345312";
        
        // Variables to store data
        let teamOwnerMapping = {};
        let playerStats = {};
        let matchesProcessed = 0;
        let playerNameToId = {}; // Track players by name to prevent duplicates
        let matchHighestScorers = {}; // Track highest scorer for each match
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            fetchData();
            // Auto-refresh every 5 minutes
            setInterval(fetchData, 5 * 60 * 1000);
        });
        
        // Function to refresh data manually
        function refreshData() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('player-table-container').innerHTML = '';
            document.getElementById('error-container').innerHTML = '';
            fetchData();
        }
        
        // Add timestamp to prevent caching
        function addTimestamp(url) {
            return `${url}${url.includes('?') ? '&' : '?'}_t=${Date.now()}`;
        }
        
        // Main function to fetch all required data
        async function fetchData() {
            try {
                // Reset data
                playerStats = {};
                matchesProcessed = 0;
                
                // Step 1: Load team owner mapping from CSV
                await fetchTeamOwnerMapping();
                console.log("Team owner mapping loaded:", Object.keys(teamOwnerMapping).length, "players");
                
                // Initialize player stats with base values from team mapping
                initializePlayerStats();
                
                // Step 2: Fetch all matches for the series
                const matches = await fetchSeriesMatches(API_KEY, IPL_2025_SERIES_ID);
                console.log("Fetched matches:", matches.length);
                
                // Step 3: Process each match to calculate player stats
                if (matches && matches.length > 0) {
                    const startedMatches = matches.filter(match => match.matchStarted);
                    console.log(`Found ${startedMatches.length} started matches`);
                    
                    for (const match of startedMatches) {
                        document.getElementById('loading').textContent = `Loading match details for ${match.name}...`;
                        try {
                            const matchDetails = await fetchMatchDetails(API_KEY, match.id);
                            if (matchDetails && matchDetails.status === "success") {
                                processMatchData(matchDetails);
                                matchesProcessed++;
                            }
                        } catch (matchError) {
                            console.error(`Error processing match ${match.id}:`, matchError);
                        }
                    }
                }
                
                // Step 4: Calculate and display player scores
                calculatePlayerScores();
                displayPlayerTable();
                
                // Update the timestamp
                const now = new Date();
                document.getElementById('update-time').textContent = now.toLocaleString();
                document.getElementById('loading').style.display = 'none';
                
            } catch (error) {
                console.error("Error fetching data:", error);
                document.getElementById('error-container').innerHTML = `
                    <div class="error">
                        <h3>Error loading data</h3>
                        <p>${error.message}</p>
                    </div>
                `;
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Function to fetch team-owner mapping from CSV
        async function fetchTeamOwnerMapping() {
            try {
                console.log("Fetching team owner mapping");
                // First try to fetch from GitHub Pages
                const response = await fetch(`teams.csv?t=${Date.now()}`, {
                    cache: 'no-store'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch teams.csv: ${response.status}`);
                }
                
                const csvText = await response.text();
                console.log("CSV text length:", csvText.length);
                teamOwnerMapping = parseTeamOwnerMapping(csvText);
                
            } catch (error) {
                console.error("Error fetching team-owner mapping:", error);
                throw error;
            }
        }
        
        // Function to parse CSV text into team-owner mapping
        function parseTeamOwnerMapping(csvText) {
            console.log("Parsing team owner mapping");
            const mapping = {};
            
            // Split the CSV text into lines
            const lines = csvText.trim().split('\n');
            console.log("CSV lines:", lines.length);
            
            // Process each line
            for (let i = 1; i < lines.length; i++) { // Skip header row
                const line = lines[i].trim();
                if (!line) continue; // Skip empty lines
                
                const values = line.split(',');
                if (values.length >= 8) {
                    // Extract values from CSV columns
                    const player_id = String(values[4]).trim();
                    const team_id = String(values[5]).trim();
                    const player_name = values[6].trim();
                    const owner = values[7].trim();
                    
                    // Store in mapping
                    mapping[player_id] = {
                        team_id: team_id,
                        player_name: player_name,
                        owner: owner
                    };
                    
                    console.log(`Added player: ${player_id} - ${player_name} (${owner})`);
                }
            }
            
            console.log("Mapping created with", Object.keys(mapping).length, "players");
            return mapping;
        }
        
        // Function to initialize player stats with base values
        function initializePlayerStats() {
            for (const playerId in teamOwnerMapping) {
                const playerInfo = teamOwnerMapping[playerId];
                playerStats[playerId] = {
                    player_id: playerId,
                    player_name: playerInfo.player_name,
                    team_id: playerInfo.team_id,
                    owner: playerInfo.owner,
                    runs: 0,
                    balls_faced: 0,
                    wickets: 0,
                    wicket_bowled: 0,
                    wicket_lbw: 0,
                    wicket_caught: 0,
                    wicket_stumped: 0,
                    wicket_other: 0,
                    balls_bowled: 0,
                    catches: 0,
                    run_outs: 0,
                    economy: 0,
                    high_score: 0,
                    strike_rate: 0,
                    runs_conceded: 0,
                    dot_balls: 0,
                    good_ones: 0,
                    score: 0,
                    matchScores: {}, // Track scores per match
                    matchStats: {},  // Track stats per match
                    multiplier_count: 0 // Track how many times player got 1.3x multiplier
                };
            }
            console.log("Initialized player stats for", Object.keys(playerStats).length, "players");
        }
        
        // Function to fetch series matches
        async function fetchSeriesMatches(apiKey, seriesId) {
            try {
                console.log(`Fetching matches for series: ${seriesId}`);
                const url = addTimestamp(`https://api.cricapi.com/v1/series_info?apikey=${apiKey}&id=${seriesId}`);
                
                const response = await fetch(url, {
                    method: 'GET',
                    cache: 'no-store'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch series matches: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Series API Response:', data);
                
                if (data.status !== "success") {
                    throw new Error(data.info || data.error || 'API returned unsuccessful status');
                }
                
                return data.data.matchList || [];
                
            } catch (error) {
                console.error("Error fetching series matches:", error);
                return [];
            }
        }
        
        // Function to fetch match details
        async function fetchMatchDetails(apiKey, matchId) {
            try {
                console.log(`Fetching scorecard for match: ${matchId}`);
                const url = addTimestamp(`https://api.cricapi.com/v1/match_scorecard?apikey=${apiKey}&id=${matchId}`);
                
                const response = await fetch(url, {
                    method: 'GET',
                    cache: 'no-store'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch match details: ${response.status}`);
                }
                
                const data = await response.json();
                console.log(`Match scorecard API Response for ${matchId}:`, data.status);
                return data;
                
            } catch (error) {
                console.error(`Error fetching match ${matchId} details:`, error);
                return null;
            }
        }
        
        // Function to process match data and update player stats
        function processMatchData(matchData) {
            console.log("Processing match data from scorecard");
            
            if (!matchData || !matchData.data || !matchData.data.scorecard) {
                console.warn("No scorecard data found in match");
                return;
            }
            
            const matchId = matchData.data.id;
            const scorecard = matchData.data.scorecard;
            console.log(`Processing scorecard for match: ${matchId}`);
            
            // Reset player scores for this match
            const matchPlayerScores = {};
            
            // Process each innings
            scorecard.forEach(inning => {
                // Process batting stats
                if (inning.batting) {
                    inning.batting.forEach(batsman => {
                        processBatsman(batsman, matchId, matchPlayerScores);
                    });
                }
                
                // Process bowling stats
                if (inning.bowling) {
                    inning.bowling.forEach(bowler => {
                        processBowler(bowler, matchId, matchPlayerScores);
                    });
                }
                
                // Process fielding stats
                if (inning.catching) {
                    inning.catching.forEach(fielder => {
                        processFielder(fielder, matchId, matchPlayerScores);
                    });
                }
            });
            
            // Store match scores for each player
            for (const playerId in matchPlayerScores) {
                if (playerStats[playerId]) {
                    playerStats[playerId].matchScores = playerStats[playerId].matchScores || {};
                    playerStats[playerId].matchScores[matchId] = matchPlayerScores[playerId];
                }
            }
            
            // Find player with highest score for this match
            let highestScore = -Infinity;
            let highestScorerId = null;
            
            for (const playerId in matchPlayerScores) {
                const score = matchPlayerScores[playerId];
                if (score > highestScore) {
                    highestScore = score;
                    highestScorerId = playerId;
                }
            }
            
            if (highestScorerId) {
                matchHighestScorers[matchId] = {
                    playerId: highestScorerId,
                    score: highestScore,
                    playerName: playerStats[highestScorerId]?.player_name || "Unknown Player"
                };
                console.log(`Highest scorer for match ${matchId}: ${matchHighestScorers[matchId].playerName} with ${highestScore} points`);
            }
        }
        
        // Process batsman stats
        function processBatsman(batsman, matchId, matchPlayerScores) {
            if (!batsman || !batsman.batsman || !batsman.batsman.id) return;
            
            const batterId = String(batsman.batsman.id || "");
            const batterName = batsman.batsman.name || "";
            
            if (!batterId || !batterName) return;
            
            // Get or create proper player ID to prevent duplicates
            const canonicalId = getOrCreatePlayer(batterId, batterName);
            
            if (!canonicalId || !playerStats[canonicalId]) return;
            
            // Initialize match score for this player if it doesn't exist
            matchPlayerScores[canonicalId] = matchPlayerScores[canonicalId] || 0;
            
            // Initialize per-match stats tracking if it doesn't exist
            if (!playerStats[canonicalId].matchStats) {
                playerStats[canonicalId].matchStats = {};
            }
            
            // Initialize this match's stats if they don't exist
            if (!playerStats[canonicalId].matchStats[matchId]) {
                playerStats[canonicalId].matchStats[matchId] = {
                    runs: 0,
                    balls_faced: 0,
                    wickets: 0,
                    wicket_bowled: 0,
                    wicket_lbw: 0,
                    wicket_caught: 0,
                    wicket_stumped: 0,
                    wicket_other: 0,
                    balls_bowled: 0,
                    catches: 0,
                    run_outs: 0,
                    economy: 0,
                    high_score: 0,
                    strike_rate: 0,
                    runs_conceded: 0,
                    dot_balls: 0,
                    good_ones: 0
                };
            }
            
            // Get reference to this match's stats
            const matchStats = playerStats[canonicalId].matchStats[matchId];
            
            // Update batting stats
            const runs = parseInt(batsman.r || 0);
            const ballsFaced = parseInt(batsman.b || 0);
            const fours = parseInt(batsman['4s'] || 0);
            const sixes = parseInt(batsman['6s'] || 0);
            const sr = parseFloat(batsman.sr || 0);
            
            // Update overall stats
            playerStats[canonicalId].runs += runs;
            playerStats[canonicalId].balls_faced += ballsFaced;
            
            // Update match-specific stats
            matchStats.runs += runs;
            matchStats.balls_faced += ballsFaced;
            
            // Check if there is a dismissal and update the bowler's wicket types
            if (batsman.dismissal && batsman.bowler && batsman.bowler.id) {
                const dismissalType = batsman.dismissal.toLowerCase();
                const bowlerId = String(batsman.bowler.id || "");
                const bowlerName = batsman.bowler.name || "";
                
                if (bowlerId && bowlerName) {
                    // Get or create the bowler
                    const bowlerCanonicalId = getOrCreatePlayer(bowlerId, bowlerName);
                    
                    if (bowlerCanonicalId && playerStats[bowlerCanonicalId]) {
                        // Initialize bowler's match stats if needed
                        if (!playerStats[bowlerCanonicalId].matchStats[matchId]) {
                            playerStats[bowlerCanonicalId].matchStats[matchId] = {
                                runs: 0,
                                balls_faced: 0,
                                wickets: 0,
                                wicket_bowled: 0,
                                wicket_lbw: 0,
                                wicket_caught: 0,
                                wicket_stumped: 0,
                                wicket_other: 0,
                                balls_bowled: 0,
                                catches: 0,
                                run_outs: 0,
                                economy: 0,
                                high_score: 0,
                                strike_rate: 0,
                                runs_conceded: 0,
                                dot_balls: 0,
                                good_ones: 0
                            };
                        }
                        
                        // Update wicket type for the bowler
                        if (dismissalType === 'bowled') {
                            playerStats[bowlerCanonicalId].wicket_bowled += 1;
                            playerStats[bowlerCanonicalId].matchStats[matchId].wicket_bowled += 1;
                        } else if (dismissalType === 'lbw') {
                            playerStats[bowlerCanonicalId].wicket_lbw += 1;
                            playerStats[bowlerCanonicalId].matchStats[matchId].wicket_lbw += 1;
                        } else if (dismissalType === 'catch' || dismissalType === 'caught') {
                            playerStats[bowlerCanonicalId].wicket_caught += 1;
                            playerStats[bowlerCanonicalId].matchStats[matchId].wicket_caught += 1;
                        } else if (dismissalType === 'stumped') {
                            playerStats[bowlerCanonicalId].wicket_stumped += 1;
                            playerStats[bowlerCanonicalId].matchStats[matchId].wicket_stumped += 1;
                        } else {
                            playerStats[bowlerCanonicalId].wicket_other += 1;
                            playerStats[bowlerCanonicalId].matchStats[matchId].wicket_other += 1;
                        }
                    }
                }
            }
            
            // Update high score if this innings is higher
            if (runs > playerStats[canonicalId].high_score) {
                playerStats[canonicalId].high_score = runs;
            }
            
            // Update match high score
            matchStats.high_score = runs;
            
            // Update strike rates
            matchStats.strike_rate = sr;
            if (playerStats[canonicalId].balls_faced > 0) {
                playerStats[canonicalId].strike_rate = 
                    (playerStats[canonicalId].runs / playerStats[canonicalId].balls_faced) * 100;
            }
            
            // Calculate the batting score contribution for this match
            // Formula: runs + (sr - 150) * max(runs, balls) + milestone bonuses
            const srBonus = (sr / 100 - 1.5) * Math.max(runs, ballsFaced);
            const milestoneBonus = (runs >= 50 ? 8 : 0) + (runs >= 100 ? 8 : 0);
            const battingScore = runs + srBonus + milestoneBonus;
            
            // Update player's score for this match
            matchPlayerScores[canonicalId] += battingScore;
            
            console.log(`Added batting stats for ${batterName}: ${runs} runs (${ballsFaced} balls), score contribution: ${battingScore.toFixed(2)}`);
        }
        
        // Process bowler stats
        function processBowler(bowler, matchId, matchPlayerScores) {
            if (!bowler || !bowler.bowler || !bowler.bowler.id) return;
            
            const bowlerId = String(bowler.bowler.id || "");
            const bowlerName = bowler.bowler.name || "";
            
            if (!bowlerId || !bowlerName) return;
            
            // Get or create proper player ID to prevent duplicates
            const canonicalId = getOrCreatePlayer(bowlerId, bowlerName);
            
            if (!canonicalId || !playerStats[canonicalId]) return;
            
            // Initialize match score for this player if it doesn't exist
            matchPlayerScores[canonicalId] = matchPlayerScores[canonicalId] || 0;
            
            // Initialize per-match stats tracking if it doesn't exist
            if (!playerStats[canonicalId].matchStats) {
                playerStats[canonicalId].matchStats = {};
            }
            
            // Initialize this match's stats if they don't exist
            if (!playerStats[canonicalId].matchStats[matchId]) {
                playerStats[canonicalId].matchStats[matchId] = {
                    runs: 0,
                    balls_faced: 0,
                    wickets: 0,
                    wicket_bowled: 0,
                    wicket_lbw: 0,
                    wicket_caught: 0,
                    wicket_stumped: 0,
                    wicket_other: 0,
                    balls_bowled: 0,
                    catches: 0,
                    run_outs: 0,
                    economy: 0,
                    high_score: 0,
                    strike_rate: 0,
                    runs_conceded: 0,
                    dot_balls: 0,
                    good_ones: 0
                };
            }
            
            // Get reference to this match's stats
            const matchStats = playerStats[canonicalId].matchStats[matchId];
            
            // Parse bowling stats
            const overs = parseFloat(bowler.o || 0);
            const wickets = parseInt(bowler.w || 0);
            const runsConceded = parseInt(bowler.r || 0);
            const economy = parseFloat(bowler.eco || 0);
            const wides = parseInt(bowler.wd || 0);
            const noBalls = parseInt(bowler.nb || 0);
            
            // Calculate balls bowled (6 balls per over)
            const completedOvers = Math.floor(overs);
            const partialOver = (overs - completedOvers) * 10;
            const ballsBowled = completedOvers * 6 + partialOver;
            
            // Update overall stats
            playerStats[canonicalId].wickets += wickets;
            playerStats[canonicalId].balls_bowled += ballsBowled;
            playerStats[canonicalId].runs_conceded += runsConceded;
            
            // Update match-specific stats
            matchStats.wickets += wickets;
            matchStats.balls_bowled += ballsBowled;
            matchStats.runs_conceded += runsConceded;
            matchStats.economy = economy;
            
            // Estimate dot balls using the formula: max(balls_bowled - runs_conceded / 2, 0)
            const estimatedDotBalls = Math.max(0, ballsBowled - runsConceded / 2);
            matchStats.dot_balls += Math.round(estimatedDotBalls);
            playerStats[canonicalId].dot_balls += Math.round(estimatedDotBalls);
            
            // Calculate economy for overall stats
            if (playerStats[canonicalId].balls_bowled >= 6) {
                const totalOvers = Math.floor(playerStats[canonicalId].balls_bowled / 6) + 
                    (playerStats[canonicalId].balls_bowled % 6) / 10;
                playerStats[canonicalId].economy = 
                    playerStats[canonicalId].runs_conceded / totalOvers;
            }
            
            // Calculate bowling score
            // Formula: 3 * (1.5 * balls - runs) + 20 * wickets + 10 * good_ones + dot_balls + (wickets >= 3 ? 15 : 0)
            // Note: We now calculate good_ones as the sum of wicket_bowled and wicket_lbw
            const economyBonus = 3 * (1.5 * ballsBowled - runsConceded);
            const wicketsBonus = wickets * 20;
            const goodOnes = playerStats[canonicalId].wicket_bowled + playerStats[canonicalId].wicket_lbw;
            const goodOnesBonus = goodOnes * 10;
            const dotBallsBonus = Math.round(estimatedDotBalls);
            const threeWicketBonus = (wickets >= 3) ? 15 : 0;
            
            const bowlingScore = economyBonus + wicketsBonus + goodOnesBonus + dotBallsBonus + threeWicketBonus;
            
            // Update player's score for this match
            matchPlayerScores[canonicalId] += bowlingScore;
            
            console.log(`Added bowling stats for ${bowlerName}: ${wickets} wickets (${runsConceded} runs), score contribution: ${bowlingScore.toFixed(2)}`);
        }
        
        // Process fielder stats
        function processFielder(fielder, matchId, matchPlayerScores) {
            if (!fielder || !fielder.catcher || !fielder.catcher.id) return;
            
            const fielderId = String(fielder.catcher.id || "");
            const fielderName = fielder.catcher.name || "";
            
            if (!fielderId || !fielderName) return;
            
            // Get or create proper player ID to prevent duplicates
            const canonicalId = getOrCreatePlayer(fielderId, fielderName);
            
            if (!canonicalId || !playerStats[canonicalId]) return;
            
            // Initialize match score for this player if it doesn't exist
            matchPlayerScores[canonicalId] = matchPlayerScores[canonicalId] || 0;
            
            // Initialize per-match stats tracking if it doesn't exist
            if (!playerStats[canonicalId].matchStats) {
                playerStats[canonicalId].matchStats = {};
            }
            
            // Initialize this match's stats if they don't exist
            if (!playerStats[canonicalId].matchStats[matchId]) {
                playerStats[canonicalId].matchStats[matchId] = {
                    runs: 0,
                    balls_faced: 0,
                    wickets: 0,
                    balls_bowled: 0,
                    catches: 0,
                    run_outs: 0,
                    economy: 0,
                    high_score: 0,
                    strike_rate: 0,
                    runs_conceded: 0,
                    dot_balls: 0,
                    good_ones: 0
                };
            }
            
            // Get reference to this match's stats
            const matchStats = playerStats[canonicalId].matchStats[matchId];
            
            // Get fielding contributions
            const catches = parseInt(fielder.catch || 0);
            const runOuts = parseInt(fielder.runout || 0);
            
            // Update overall stats
            playerStats[canonicalId].catches += catches;
            playerStats[canonicalId].run_outs += runOuts;
            
            // Update match-specific stats
            matchStats.catches += catches;
            matchStats.run_outs += runOuts;
            
            // Calculate fielding score (10 points per catch/run-out)
            const fieldingScore = (catches + runOuts) * 10;
            
            // Update player's score for this match
            matchPlayerScores[canonicalId] += fieldingScore;
            
            console.log(`Added fielding stats for ${fielderName}: ${catches} catches, ${runOuts} run outs, score contribution: ${fieldingScore}`);
        }
        
        // Helper to extract catcher ID - not needed with the scorecard API
        function getCatcherId(ball) {
            // This function is no longer used with the scorecard API
            return null;
        }
        
        // Function to get existing player or create a new one, preventing duplicates
        function getOrCreatePlayer(playerId, playerName) {
            if (!playerName) return playerId;
            
            // Normalize player name for case-insensitive matching
            const normalizedName = playerName.trim().toLowerCase();
            
            // Check if we've seen this player name before
            if (playerNameToId[normalizedName]) {
                // We have this player already with a different ID
                const existingId = playerNameToId[normalizedName];
                
                if (existingId !== playerId) {
                    console.log(`Found duplicate player! ${playerName} has IDs: ${existingId} and ${playerId}`);
                    
                    // If we have stats for this new ID, merge them into the existing player
                    if (playerStats[playerId]) {
                        mergePlayerStats(existingId, playerId);
                        // Delete the duplicate entry
                        delete playerStats[playerId];
                    }
                }
                
                // Return the canonical ID for this player
                return existingId;
            }
            
            // Check for common name variations (e.g., "V Kohli" vs "Virat Kohli")
            // This helps match players across different formats in the API
            const matchedId = findPlayerByNameVariation(normalizedName);
            if (matchedId) {
                playerNameToId[normalizedName] = matchedId;
                return matchedId;
            }
            
            // Check for existing player in team mapping by ID
            if (teamOwnerMapping[playerId]) {
                playerNameToId[normalizedName] = playerId;
                return playerId;
            }
            
            // Check if player exists in team mapping by name
            let foundId = null;
            for (const [id, info] of Object.entries(teamOwnerMapping)) {
                if (info.player_name.toLowerCase() === normalizedName) {
                    foundId = id;
                    break;
                }
            }
            
            if (foundId) {
                playerNameToId[normalizedName] = foundId;
                
                // If we have stats for the API ID, merge them into the CSV ID
                if (playerStats[playerId] && playerId !== foundId) {
                    mergePlayerStats(foundId, playerId);
                    // Delete the duplicate entry
                    delete playerStats[playerId];
                }
                
                return foundId;
            }
            
            // This is a new player not in our CSV
            // Create player record if it doesn't exist
            if (!playerStats[playerId]) {
                const ownerInfo = findOwnerByName(playerName);
                playerStats[playerId] = {
                    player_id: playerId,
                    player_name: playerName,
                    team_id: ownerInfo.team_id || "",
                    owner: ownerInfo.owner || "Unknown",
                    runs: 0,
                    balls_faced: 0,
                    wickets: 0,
                    wicket_bowled: 0,
                    wicket_lbw: 0,
                    wicket_caught: 0,
                    wicket_stumped: 0,
                    wicket_other: 0,
                    balls_bowled: 0,
                    catches: 0,
                    run_outs: 0,
                    economy: 0,
                    high_score: 0,
                    strike_rate: 0,
                    runs_conceded: 0,
                    dot_balls: 0,
                    good_ones: 0,
                    score: 0,
                    matchScores: {}, // Track scores per match
                    matchStats: {},   // Track stats per match
                    multiplier_count: 0 // Track how many times player got 1.3x multiplier
                };
                console.log(`Added new player: ${playerName} (${playerId})`);
            }
            
            // Register this player
            playerNameToId[normalizedName] = playerId;
            return playerId;
        }
        
        // Helper function to find players by name variations
        function findPlayerByNameVariation(normalizedName) {
            // Common abbreviations and variations
            // For example, "V Kohli" should match "Virat Kohli"
            for (const [id, info] of Object.entries(teamOwnerMapping)) {
                const fullName = info.player_name.toLowerCase();
                
                // Case 1: Full name in mapping matches part of the name from API
                if (normalizedName.includes(fullName)) {
                    return id;
                }
                
                // Case 2: First initial + last name (e.g. "V Kohli" for "Virat Kohli")
                const nameParts = fullName.split(' ');
                if (nameParts.length >= 2) {
                    const lastName = nameParts[nameParts.length - 1];
                    const firstInitial = nameParts[0][0];
                    
                    // Check if the name matches pattern "F Lastname" (e.g. "V Kohli")
                    const initialLastNamePattern = `${firstInitial} ${lastName}`;
                    if (normalizedName === initialLastNamePattern) {
                        return id;
                    }
                    
                    // Check if last name matches and it's a unique last name
                    if (normalizedName.includes(lastName) && lastName.length > 3) {
                        // Check if this last name is unique enough
                        let lastNameCount = 0;
                        for (const otherInfo of Object.values(teamOwnerMapping)) {
                            if (otherInfo.player_name.toLowerCase().includes(lastName)) {
                                lastNameCount++;
                            }
                        }
                        
                        // If this last name is unique in our mapping, use it
                        if (lastNameCount === 1) {
                            return id;
                        }
                    }
                }
            }
            
            return null;
        }
        
        // Function to merge stats from sourceId into targetId
        function mergePlayerStats(targetId, sourceId) {
            if (!playerStats[targetId] || !playerStats[sourceId]) return;
            
            console.log(`Merging player stats from ${sourceId} to ${targetId}`);
            
            const target = playerStats[targetId];
            const source = playerStats[sourceId];
            
            // Merge numerical stats
            target.runs += source.runs;
            target.balls_faced += source.balls_faced;
            target.wickets += source.wickets;
            target.wicket_bowled += source.wicket_bowled || 0;
            target.wicket_lbw += source.wicket_lbw || 0;
            target.wicket_caught += source.wicket_caught || 0;
            target.wicket_stumped += source.wicket_stumped || 0;
            target.wicket_other += source.wicket_other || 0;
            target.balls_bowled += source.balls_bowled;
            target.catches += source.catches;
            target.run_outs += source.run_outs;
            target.runs_conceded += source.runs_conceded;
            target.dot_balls += source.dot_balls;
            target.good_ones += source.good_ones;
            
            // Update high score if needed
            if (source.high_score > target.high_score) {
                target.high_score = source.high_score;
            }
            
            // Recalculate strike rate
            if (target.balls_faced > 0) {
                target.strike_rate = (target.runs / target.balls_faced) * 100;
            }
            
            // Recalculate economy
            if (target.balls_bowled >= 6) {
                const overs = Math.floor(target.balls_bowled / 6) + (target.balls_bowled % 6) / 10;
                target.economy = target.runs_conceded / overs;
            }
            
            console.log(`Merged stats for ${target.player_name}`);
        }
        
        // Helper function to find owner info by player name
        function findOwnerByName(playerName) {
            if (!playerName) return { owner: "Unknown", team_id: "" };
            
            // Look for exact name matches first
            for (const [playerId, info] of Object.entries(teamOwnerMapping)) {
                if (info.player_name.toLowerCase() === playerName.toLowerCase()) {
                    console.log(`Found exact owner match for: ${playerName} -> ${info.owner}`);
                    return { owner: info.owner, team_id: info.team_id };
                }
            }
            
            // No special cases - just return Unknown if no match found
            return { owner: "Unknown", team_id: "" };
        }
        
        // Calculate player scores using the provided score function
        function calculatePlayerScores() {
            console.log("Calculating player scores on a per-match basis");
            
            for (const playerId in playerStats) {
                const player = playerStats[playerId];
                
                // Reset the player's total score
                player.score = 0;
                player.multiplier_count = 0;
                
                // Track which matches received multipliers
                const multipliedMatches = [];
                
                // Calculate score for each match separately, then sum up
                if (player.matchStats) {
                    for (const matchId in player.matchStats) {
                        const matchStats = player.matchStats[matchId];
                        
                        // Calculate score for this match using the formula
                        let matchScore = calculateMatchScore(matchStats);
                        
                        // Apply multiplier if this player was the highest scorer in this match
                        if (matchHighestScorers[matchId] && matchHighestScorers[matchId].playerId === playerId) {
                            matchScore = matchScore * 1.3;
                            multipliedMatches.push(matchId);
                            player.multiplier_count += 1;
                            console.log(`Applied 1.3x multiplier to ${player.player_name}'s score of ${(matchScore/1.3).toFixed(2)} â†’ ${matchScore.toFixed(2)} in match ${matchId}`);
                        }
                        
                        // Add this match's score to the player's total
                        player.score += matchScore;
                        
                        // Store the calculated match score
                        player.matchScores[matchId] = matchScore;
                    }
                }
                
                // Round the final score
                player.score = Math.round(player.score);
                player.multipliedMatches = multipliedMatches;
                
                // Log the final score
                console.log(`${player.player_name} final score: ${player.score} (with multiplier on ${multipliedMatches.length} matches)`);
            }
            
            console.log("Finished calculating scores for all players");
        }
        
        // Function to calculate a player's score for a single match
        function calculateMatchScore(stats) {
            // Batting score
            let batsman_score = 0;
            if (stats.balls_faced > 0) {
                const sr = stats.runs / stats.balls_faced;
                batsman_score = stats.runs + (sr - 1.5) * Math.max(stats.runs, stats.balls_faced) + 
                              (stats.runs >= 50 ? 8 : 0) + (stats.runs >= 100 ? 8 : 0);
            }
            
            // Bowling score
            let bowlers_score = 0;
            if (stats.balls_bowled > 0) {
                // Calculate good ones as the sum of bowled and lbw dismissals
                const good_ones = stats.wicket_bowled + stats.wicket_lbw;
                
                bowlers_score = 3 * (1.5 * stats.balls_bowled - stats.runs_conceded) + 
                              stats.wickets * 20 + good_ones * 10 + 
                              (stats.wickets >= 3 ? 15 : 0) + stats.dot_balls;
            }
            
            // Fielding score (catches and run-outs)
            const fielding_score = (stats.catches + stats.run_outs) * 10;
            
            // Final score for this match
            return batsman_score + bowlers_score + fielding_score + 4;
        }
        
        // Function to display player table
        function displayPlayerTable() {
            console.log("Displaying player table");
            const container = document.getElementById('player-table-container');
            
            // Get all players and sort by score (descending)
            const players = Object.values(playerStats).sort((a, b) => b.score - a.score);
            
            // Create table HTML
            let tableHtml = `
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Owner</th>
                            <th>Runs</th>
                            <th>Balls</th>
                            <th>Wickets</th>
                            <th>R.Conc</th>
                            <th>Bld</th>
                            <th>LBW</th>
                            <th>Ct</th>
                            <th>St</th>
                            <th>Ctch</th>
                            <th>RO</th>
                            <th>1.3Ã—</th>
                            <th>Score</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Add player rows
            players.forEach((player, index) => {
                // Add a highlight for players who got the multiplier
                const rowClass = player.multipliedMatches && player.multipliedMatches.length > 0 ? 
                    'style="background-color: #ffffd0;"' : '';
                
                // Create a star icon with the number of matches that got multiplier
                const starIcon = player.multipliedMatches && player.multipliedMatches.length > 0 ? 
                    ` ðŸŒŸÃ—${player.multipliedMatches.length}` : '';
                
                tableHtml += `
                    <tr ${rowClass}>
                        <td>${index + 1}</td>
                        <td>${player.player_name}${starIcon}</td>
                        <td>${player.owner}</td>
                        <td>${player.runs}</td>
                        <td>${player.balls_faced}</td>
                        <td>${player.wickets}</td>
                        <td>${player.runs_conceded}</td>
                        <td>${player.wicket_bowled}</td>
                        <td>${player.wicket_lbw}</td>
                        <td>${player.wicket_caught}</td>
                        <td>${player.wicket_stumped}</td>
                        <td>${player.catches}</td>
                        <td>${player.run_outs}</td>
                        <td>${player.multiplier_count}</td>
                        <td><strong>${player.score}</strong></td>
                    </tr>
                `;
            });
            
            tableHtml += `
                    </tbody>
                </table>
                <div class="stats-info">
                    Matches processed: ${matchesProcessed} | Players: ${players.length}
                </div>
            `;
            
            // Update the container
            container.innerHTML = tableHtml;
        }
    </script>
</body>
</html> 