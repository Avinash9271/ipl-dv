<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cricket Player Dashboard</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #0056b3;
            text-align: center;
        }
        #loading {
            text-align: center;
            font-size: 18px;
            margin: 30px 0;
            color: #666;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #0056b3;
            color: white;
            position: sticky;
            top: 0;
        }
        tr:hover {
            background-color: #f1f8ff;
        }
        .error {
            color: red;
            text-align: center;
            padding: 20px;
            background-color: #ffeeee;
            border-radius: 5px;
            margin: 20px 0;
        }
        .refresh-btn, .nav-btn {
            background-color: #0056b3;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        .refresh-btn:hover, .nav-btn:hover {
            background-color: #003d7a;
        }
        .button-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        .stats-info {
            text-align: center;
            margin-bottom: 20px;
            color: #666;
        }
        .view-controls {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        #player-search {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        #player-search input {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 10px;
            width: 250px;
        }
        #player-search button {
            padding: 8px 15px;
            border: none;
            background-color: #0056b3;
            color: white;
            border-radius: 4px;
            cursor: pointer;
        }
        .tab-active {
            background-color: #003d7a;
        }
        #team-dashboard, #player-matches {
            display: none;
        }
        .team-card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 15px;
            margin: 15px 0;
        }
        .team-card h3 {
            color: #0056b3;
            margin-top: 0;
        }
        .team-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        .match-card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 15px;
            margin: 15px 0;
        }
        .match-card h3 {
            color: #0056b3;
            margin-top: 0;
        }
        .match-details {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        .stat-box {
            flex: 1;
            min-width: 120px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        .stat-box h4 {
            margin: 0 0 5px 0;
            color: #0056b3;
        }
        .accordion-container {
            width: 100%;
        }
        .team-accordion {
            width: 100%;
            margin-bottom: 15px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background-color: white;
        }
        .team-header {
            background-color: #f8f8f8;
            padding: 15px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }
        .team-header:hover {
            background-color: #f0f8ff;
        }
        .team-header h3 {
            margin: 0;
            color: #0056b3;
        }
        .team-summary {
            margin: 5px 0 0;
            font-size: 14px;
            color: #666;
        }
        .expand-icon {
            font-size: 20px;
            font-weight: bold;
            color: #0056b3;
            transition: transform 0.2s;
        }
        .expand-icon.open {
            transform: rotate(45deg);
        }
        .team-content {
            padding: 0;
            border-top: 1px solid #eee;
            background-color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Cricket Player Dashboard</h1>
        <div class="stats-info">Last updated: <span id="update-time"></span></div>
        <div id="loading">Loading player data...</div>
        <div id="error-container"></div>
        
        <div class="view-controls">
            <button class="nav-btn tab-active" onclick="showTab('player-table-container')">Player Leaderboard</button>
            <button class="nav-btn" onclick="showTab('team-dashboard')">Team Dashboard</button>
            <button class="nav-btn" onclick="showTab('player-matches')">Player Match History</button>
        </div>
        
        <div id="player-table-container"></div>
        
        <div id="team-dashboard"></div>
        
        <div id="player-matches">
            <div id="player-search">
                <input type="text" id="player-search-input" placeholder="Enter player name...">
                <button onclick="searchPlayerMatches()">Show Matches</button>
            </div>
            <div id="player-matches-container"></div>
        </div>
        
        <div class="button-container">
            <button class="refresh-btn" onclick="refreshData()">Refresh Data</button>
        </div>
    </div>

    <script>
        // Constants
        // Base API key without the last 4 characters
        const BASE_API_KEY = "9de714ba-d89b-40de-adae-2c3f544c";
        const IPL_2025_SERIES_ID = "d5a498c8-7596-4b93-8ab0-e0efc3345312";
        
        // Variables to store data
        let teamOwnerMapping = {};
        let playerStats = {};
        let matchesProcessed = 0;
        let playerNameToId = {}; // Track players by name to prevent duplicates
        let matchHighestScorers = {}; // Track highest scorer for each match
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Log all container IDs to help with debugging
            console.log("player-table-container exists:", !!document.getElementById('player-table-container'));
            console.log("team-dashboard exists:", !!document.getElementById('team-dashboard'));
            console.log("player-matches exists:", !!document.getElementById('player-matches'));
            
            fetchData();
            // Auto-refresh every 5 minutes
            setInterval(fetchData, 5 * 60 * 1000);
        });
        
        // Function to refresh data manually
        function refreshData() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('player-table-container').innerHTML = '';
            document.getElementById('error-container').innerHTML = '';
            fetchData();
        }
        
        // Add timestamp to prevent caching
        function addTimestamp(url) {
            return `${url}${url.includes('?') ? '&' : '?'}_t=${Date.now()}`;
        }
        
        // Function to get the complete API key by reading the last 4 characters from URL query param
        function getCompleteApiKey() {
            const urlParams = new URLSearchParams(window.location.search);
            const keySuffix = urlParams.get('key') || ''; // Default to empty string if not provided
            return BASE_API_KEY + keySuffix;
        }
        
        // Main function to fetch all data and initialize the app
        function fetchData() {
            fetchMatches()
                .then(matches => {
                    if (matches.length === 0) {
                        console.warn("No matches found or processed");
                    }
                    return Promise.resolve();
                })
                .then(() => {
                    document.getElementById('loading').style.display = 'none';
                    console.log("All player stats:", playerStats);
                    calculateAllScores();
                    displayPlayerTable();
                    displayTeamDashboard();
                    showTab('team-dashboard'); // Default to team dashboard
                })
                .catch(error => {
                    console.error("Error in data processing:", error);
                    document.getElementById('loading').textContent = "Error loading data. Please check console for details.";
                    
                    // Check if this might be an API key issue
                    const urlParams = new URLSearchParams(window.location.search);
                    if (!urlParams.has('key')) {
                        alert("API Key Error: You need to add the last 4 characters of the API key as a URL parameter. Example: ?key=477a");
                    } else if (error.toString().includes("API") || error.toString().includes("auth")) {
                        alert("API Key Error: The provided key suffix seems incorrect. Please check the 'key' parameter in the URL.");
                    }
                });
        }
        
        // Function to fetch team-owner mapping from CSV
        async function fetchTeamOwnerMapping() {
            try {
                console.log("Fetching team owner mapping");
                // First try to fetch from GitHub Pages
                const response = await fetch(`teams.csv?t=${Date.now()}`, {
                    cache: 'no-store'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch teams.csv: ${response.status}`);
                }
                
                const csvText = await response.text();
                console.log("CSV text length:", csvText.length);
                teamOwnerMapping = parseTeamOwnerMapping(csvText);
                
            } catch (error) {
                console.error("Error fetching team-owner mapping:", error);
                throw error;
            }
        }
        
        // Function to parse CSV text into team-owner mapping
        function parseTeamOwnerMapping(csvText) {
            console.log("Parsing team owner mapping");
            const mapping = {};
            
            // Split the CSV text into lines
            const lines = csvText.trim().split('\n');
            console.log("CSV lines:", lines.length);
            
            // Process each line
            for (let i = 1; i < lines.length; i++) { // Skip header row
                const line = lines[i].trim();
                if (!line) continue; // Skip empty lines
                
                const values = line.split(',');
                if (values.length >= 9) { // Ensure we have enough columns including the extra multiplier
                    // Extract values from CSV columns
                    const player_id = String(values[4]).trim();
                    const team_id = String(values[5]).trim();
                    const player_name = values[6].trim();
                    const owner = values[7].trim();
                    
                    // Parse extra_mult from column 9 (index 8) if available
                    let extra_mult = 1.0; // Default value
                    if (values.length > 8 && values[8] && !isNaN(parseFloat(values[8]))) {
                        extra_mult = 1 + parseFloat(values[8]);
                        console.log(`Found extra multiplier ${extra_mult} for ${player_name}`);
                    }
                    
                    // Store in mapping
                    mapping[player_id] = {
                        team_id: team_id,
                        player_name: player_name,
                        owner: owner,
                        extra_mult: extra_mult
                    };
                    
                    console.log(`Added player: ${player_id} - ${player_name} (${owner}), multiplier: ${extra_mult}`);
                } else {
                    // Handle rows with fewer columns (e.g., no multiplier)
                    if (values.length >= 8) {
                        const player_id = String(values[4]).trim();
                        const team_id = String(values[5]).trim();
                        const player_name = values[6].trim();
                        const owner = values[7].trim();
                        
                        mapping[player_id] = {
                            team_id: team_id,
                            player_name: player_name,
                            owner: owner,
                            extra_mult: 1.0 // Default multiplier
                        };
                        
                        console.log(`Added player without multiplier: ${player_id} - ${player_name} (${owner})`);
                    }
                }
            }
            
            console.log("Mapping created with", Object.keys(mapping).length, "players");
            return mapping;
        }
        
        // Function to initialize player stats with base values
        function initializePlayerStats() {
            for (const playerId in teamOwnerMapping) {
                const playerInfo = teamOwnerMapping[playerId];
                playerStats[playerId] = {
                    player_id: playerId,
                    player_name: playerInfo.player_name,
                    team_id: playerInfo.team_id,
                    owner: playerInfo.owner,
                    extra_mult: playerInfo.extra_mult || 1.0, // Get multiplier from team mapping
                    runs: 0,
                    balls_faced: 0,
                    wickets: 0,
                    wicket_bowled: 0,
                    wicket_lbw: 0,
                    wicket_caught: 0,
                    wicket_stumped: 0,
                    wicket_other: 0,
                    balls_bowled: 0,
                    catches: 0,
                    stumpings: 0,
                    run_outs: 0,
                    economy: 0,
                    high_score: 0,
                    strike_rate: 0,
                    runs_conceded: 0,
                    dot_balls: 0,
                    good_ones: 0,
                    score: 0,
                    matchScores: {}, // Track scores per match
                    matchStats: {},  // Track stats per match
                    multiplier_count: 0 // Track how many times player got 1.3x multiplier
                };
            }
            console.log("Initialized player stats for", Object.keys(playerStats).length, "players");
        }
        
        // Function to fetch matches and load all required data
        async function fetchMatches() {
            try {
                // Reset data
                playerStats = {};
                matchesProcessed = 0;
                
                document.getElementById('loading').textContent = "Loading team data...";
                
                // Step 1: Load team owner mapping from CSV
                await fetchTeamOwnerMapping();
                console.log("Team owner mapping loaded:", Object.keys(teamOwnerMapping).length, "players");
                
                // Initialize player stats with base values from team mapping
                initializePlayerStats();
                
                document.getElementById('loading').textContent = "Loading matches...";
                
                // Step 2: Fetch all matches for the series
                console.log(`Fetching matches for series: ${IPL_2025_SERIES_ID}`);
                const matches = await fetchSeriesMatches(IPL_2025_SERIES_ID);
                console.log("Fetched matches:", matches.length);
                
                // Step 3: Fetch each match's scorecard
                const validMatches = [];
                for (const match of matches) {
                    if (match.status !== "Match not started") {
                        document.getElementById('loading').textContent = `Loading match details for ${match.name}...`;
                        try {
                            const matchDetails = await fetchMatchDetails(match.id);
                            if (matchDetails && matchDetails.status === "success") {
                                processMatchData(matchDetails);
                                validMatches.push(match);
                                matchesProcessed++;
                            } else {
                                console.warn(`Couldn't fetch valid scorecard for ${match.name}`);
                            }
                        } catch (error) {
                            console.error(`Error processing match ${match.name}:`, error);
                        }
                    } else {
                        console.log(`Skipping match ${match.name}, not started yet`);
                    }
                }
                
                // Step 4: Set extra multipliers and calculate scores
                setExtraMultipliers();
                
                // Update the timestamp
                const now = new Date();
                document.getElementById('update-time').textContent = now.toLocaleString();
                
                return validMatches;
                
            } catch (error) {
                console.error("Error fetching matches:", error);
                // Check if this might be an API key issue
                const urlParams = new URLSearchParams(window.location.search);
                if (!urlParams.has('key')) {
                    alert("API Key Error: You need to add the last 4 characters of the API key as a URL parameter. Example: ?key=477a");
                } else if (error.toString().includes("API") || error.toString().includes("auth")) {
                    alert("API Key Error: The provided key suffix seems incorrect. Please check the 'key' parameter in the URL.");
                }
                document.getElementById('error-container').innerHTML = `
                    <div class="error">
                        <h3>Error loading data</h3>
                        <p>${error.message}</p>
                    </div>
                `;
                return [];
            }
        }
        
        // Function to fetch series matches
        async function fetchSeriesMatches(seriesId) {
            try {
                console.log(`Fetching matches for series: ${seriesId}`);
                // Get complete API key from base + URL query param
                const completeApiKey = getCompleteApiKey();
                const url = addTimestamp(`https://api.cricapi.com/v1/series_info?apikey=${completeApiKey}&id=${seriesId}`);
                
                const response = await fetch(url, {
                    method: 'GET',
                    cache: 'no-store'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch series matches: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Series API Response:', data);
                
                if (data.status !== "success") {
                    throw new Error(data.info || data.error || 'API returned unsuccessful status');
                }
                
                return data.data.matchList || [];
                
            } catch (error) {
                console.error("Error fetching series matches:", error);
                return [];
            }
        }
        
        // Function to fetch match details
        async function fetchMatchDetails(matchId) {
            try {
                console.log(`Fetching scorecard for match: ${matchId}`);
                // Get complete API key from base + URL query param
                const completeApiKey = getCompleteApiKey();
                const url = addTimestamp(`https://api.cricapi.com/v1/match_scorecard?apikey=${completeApiKey}&id=${matchId}`);
                
                const response = await fetch(url, {
                    method: 'GET',
                    cache: 'no-store'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch match details: ${response.status}`);
                }
                
                const data = await response.json();
                console.log(`Match scorecard API Response for ${matchId}:`, data.status);
                return data;
                
            } catch (error) {
                console.error(`Error fetching match ${matchId} details:`, error);
                return null;
            }
        }
        
        // Function to process match data and update player stats
        function processMatchData(matchData) {
            console.log("Processing match data from scorecard");
            
            if (!matchData || !matchData.data || !matchData.data.scorecard) {
                console.warn("No scorecard data found in match");
                return;
            }
            
            const matchId = matchData.data.id;
            const scorecard = matchData.data.scorecard;
            console.log(`Processing scorecard for match: ${matchId}`);
            
            // Reset player scores for this match
            const matchPlayerScores = {};
            
            // Process each innings
            scorecard.forEach(inning => {
                // Process batting stats
                if (inning.batting) {
                    inning.batting.forEach(batsman => {
                        processBatsman(batsman, matchId, matchPlayerScores);
                    });
                }
                
                // Process bowling stats
                if (inning.bowling) {
                    inning.bowling.forEach(bowler => {
                        processBowler(bowler, matchId, matchPlayerScores);
                    });
                }
                
                // Process fielding stats
                if (inning.catching) {
                    inning.catching.forEach(fielder => {
                        processFielder(fielder, matchId, matchPlayerScores);
                    });
                }
            });
            
            // Store match scores for each player
            for (const playerId in matchPlayerScores) {
                if (playerStats[playerId]) {
                    playerStats[playerId].matchScores = playerStats[playerId].matchScores || {};
                    playerStats[playerId].matchScores[matchId] = matchPlayerScores[playerId];
                }
            }
            
            // Find player with highest score for this match
            let highestScore = -Infinity;
            let highestScorerId = null;
            
            for (const playerId in matchPlayerScores) {
                const score = matchPlayerScores[playerId];
                if (score > highestScore) {
                    highestScore = score;
                    highestScorerId = playerId;
                }
            }
            
            if (highestScorerId) {
                matchHighestScorers[matchId] = {
                    playerId: highestScorerId,
                    score: highestScore,
                    playerName: playerStats[highestScorerId]?.player_name || "Unknown Player"
                };
                console.log(`Highest scorer for match ${matchId}: ${matchHighestScorers[matchId].playerName} with ${highestScore} points`);
            }
        }
        
        // Process batsman stats
        function processBatsman(batsman, matchId, matchPlayerScores) {
            if (!batsman || !batsman.batsman || !batsman.batsman.id) return;
            
            const batterId = String(batsman.batsman.id || "");
            const batterName = batsman.batsman.name || "";
            
            if (!batterId || !batterName) return;
            
            // Get or create proper player ID to prevent duplicates
            const canonicalId = getOrCreatePlayer(batterId, batterName);
            
            if (!canonicalId || !playerStats[canonicalId]) return;
            
            // Initialize match score for this player if it doesn't exist
            matchPlayerScores[canonicalId] = matchPlayerScores[canonicalId] || 0;
            
            // Initialize per-match stats tracking if it doesn't exist
            if (!playerStats[canonicalId].matchStats) {
                playerStats[canonicalId].matchStats = {};
            }
            
            // Initialize this match's stats if they don't exist
            if (!playerStats[canonicalId].matchStats[matchId]) {
                playerStats[canonicalId].matchStats[matchId] = {
                    runs: 0,
                    balls_faced: 0,
                    wickets: 0,
                    wicket_bowled: 0,
                    wicket_lbw: 0,
                    wicket_caught: 0,
                    wicket_stumped: 0,
                    wicket_other: 0,
                    balls_bowled: 0,
                    catches: 0,
                    run_outs: 0,
                    economy: 0,
                    high_score: 0,
                    strike_rate: 0,
                    runs_conceded: 0,
                    dot_balls: 0,
                    good_ones: 0
                };
            }
            
            // Get reference to this match's stats
            const matchStats = playerStats[canonicalId].matchStats[matchId];
            
            // Update batting stats
            const runs = parseInt(batsman.r || 0);
            const ballsFaced = parseInt(batsman.b || 0);
            const fours = parseInt(batsman['4s'] || 0);
            const sixes = parseInt(batsman['6s'] || 0);
            const sr = parseFloat(batsman.sr || 0);
            
            // Update overall stats
            playerStats[canonicalId].runs += runs;
            playerStats[canonicalId].balls_faced += ballsFaced;
            
            // Update match-specific stats
            matchStats.runs += runs;
            matchStats.balls_faced += ballsFaced;
            
            // Check if there is a dismissal and update the bowler's wicket types
            if (batsman.dismissal && batsman.bowler && batsman.bowler.id) {
                const dismissalType = batsman.dismissal.toLowerCase();
                const bowlerId = String(batsman.bowler.id || "");
                const bowlerName = batsman.bowler.name || "";
                
                if (bowlerId && bowlerName) {
                    // Get or create the bowler
                    const bowlerCanonicalId = getOrCreatePlayer(bowlerId, bowlerName);
                    
                    if (bowlerCanonicalId && playerStats[bowlerCanonicalId]) {
                        // Initialize bowler's match stats if needed
                        if (!playerStats[bowlerCanonicalId].matchStats[matchId]) {
                            playerStats[bowlerCanonicalId].matchStats[matchId] = {
                                runs: 0,
                                balls_faced: 0,
                                wickets: 0,
                                wicket_bowled: 0,
                                wicket_lbw: 0,
                                wicket_caught: 0,
                                wicket_stumped: 0,
                                wicket_other: 0,
                                balls_bowled: 0,
                                catches: 0,
                                run_outs: 0,
                                economy: 0,
                                high_score: 0,
                                strike_rate: 0,
                                runs_conceded: 0,
                                dot_balls: 0,
                                good_ones: 0
                            };
                        }
                        
                        // Update wicket type for the bowler
                        if (dismissalType === 'bowled') {
                            playerStats[bowlerCanonicalId].wicket_bowled += 1;
                            playerStats[bowlerCanonicalId].matchStats[matchId].wicket_bowled += 1;
                        } else if (dismissalType === 'lbw') {
                            playerStats[bowlerCanonicalId].wicket_lbw += 1;
                            playerStats[bowlerCanonicalId].matchStats[matchId].wicket_lbw += 1;
                        } else if (dismissalType === 'catch' || dismissalType === 'caught') {
                            playerStats[bowlerCanonicalId].wicket_caught += 1;
                            playerStats[bowlerCanonicalId].matchStats[matchId].wicket_caught += 1;
                            
                            // Credit the catch to the catcher if available
                            if (batsman.catcher && batsman.catcher.id) {
                                const catcherId = String(batsman.catcher.id || "");
                                const catcherName = batsman.catcher.name || "";
                                
                                if (catcherId && catcherName) {
                                    const catcherCanonicalId = getOrCreatePlayer(catcherId, catcherName);
                                    
                                    if (catcherCanonicalId && playerStats[catcherCanonicalId]) {
                                        // Initialize catcher's match stats if needed
                                        if (!playerStats[catcherCanonicalId].matchStats[matchId]) {
                                            playerStats[catcherCanonicalId].matchStats[matchId] = {
                                                runs: 0,
                                                balls_faced: 0,
                                                wickets: 0,
                                                wicket_bowled: 0,
                                                wicket_lbw: 0,
                                                wicket_caught: 0,
                                                wicket_stumped: 0,
                                                wicket_other: 0,
                                                balls_bowled: 0,
                                                catches: 0,
                                                run_outs: 0,
                                                economy: 0,
                                                high_score: 0,
                                                strike_rate: 0,
                                                runs_conceded: 0,
                                                dot_balls: 0,
                                                good_ones: 0
                                            };
                                        }
                                        
                                        // Update catch stats for the catcher
                                        playerStats[catcherCanonicalId].catches += 1;
                                        playerStats[catcherCanonicalId].matchStats[matchId].catches += 1;
                                        console.log(`Credited catch to ${catcherName} (from batsman dismissal processing)`);
                                        
                                        // We no longer add points here as they will be calculated in calculateMatchScore
                                    }
                                }
                            }
                        } else if (dismissalType === 'stumped') {
                            playerStats[bowlerCanonicalId].wicket_stumped += 1;
                            playerStats[bowlerCanonicalId].matchStats[matchId].wicket_stumped += 1;
                            
                            // Credit the stumping to the stumper if available
                            if (batsman.catcher && batsman.catcher.id) {
                                const stumperId = String(batsman.catcher.id || "");
                                const stumperName = batsman.catcher.name || "";
                                
                                if (stumperId && stumperName) {
                                    const stumperCanonicalId = getOrCreatePlayer(stumperId, stumperName);
                                    
                                    if (stumperCanonicalId && playerStats[stumperCanonicalId]) {
                                        // Initialize stumper's match stats if needed
                                        if (!playerStats[stumperCanonicalId].matchStats[matchId]) {
                                            playerStats[stumperCanonicalId].matchStats[matchId] = {
                                                runs: 0,
                                                balls_faced: 0,
                                                wickets: 0,
                                                wicket_bowled: 0,
                                                wicket_lbw: 0,
                                                wicket_caught: 0,
                                                wicket_stumped: 0,
                                                wicket_other: 0,
                                                balls_bowled: 0,
                                                catches: 0,
                                                run_outs: 0,
                                                economy: 0,
                                                high_score: 0,
                                                strike_rate: 0,
                                                runs_conceded: 0,
                                                dot_balls: 0,
                                                good_ones: 0
                                            };
                                        }
                                        
                                        // Update stumping stats
                                        playerStats[stumperCanonicalId].stumpings = (playerStats[stumperCanonicalId].stumpings || 0) + 1;
                                        playerStats[stumperCanonicalId].matchStats[matchId].stumpings = 
                                            (playerStats[stumperCanonicalId].matchStats[matchId].stumpings || 0) + 1;
                                        console.log(`Credited stumping to ${stumperName}`);
                                        
                                        // We no longer add points here as they will be calculated in calculateMatchScore
                                    }
                                }
                            }
                        } else {
                            playerStats[bowlerCanonicalId].wicket_other += 1;
                            playerStats[bowlerCanonicalId].matchStats[matchId].wicket_other += 1;
                        }
                    }
                }
            }
            
            // Update high score if this innings is higher
            if (runs > playerStats[canonicalId].high_score) {
                playerStats[canonicalId].high_score = runs;
            }
            
            // Update match high score
            matchStats.high_score = runs;
            
            // Update strike rates
            matchStats.strike_rate = sr;
            if (playerStats[canonicalId].balls_faced > 0) {
                playerStats[canonicalId].strike_rate = 
                    (playerStats[canonicalId].runs / playerStats[canonicalId].balls_faced) * 100;
            }
            
            // Calculate the batting score contribution for this match
            // Formula: runs + (sr - 150) * max(runs, balls) + milestone bonuses
            const srBonus = (sr / 100 - 1.5) * Math.max(runs, ballsFaced);
            const milestoneBonus = (runs >= 50 ? 8 : 0) + (runs >= 100 ? 8 : 0);
            const battingScore = runs + srBonus + milestoneBonus;
            
            // Update player's score for this match
            matchPlayerScores[canonicalId] += battingScore;
            
            console.log(`Added batting stats for ${batterName}: ${runs} runs (${ballsFaced} balls), score contribution: ${battingScore.toFixed(2)}`);
        }
        
        // Process bowler stats
        function processBowler(bowler, matchId, matchPlayerScores) {
            if (!bowler || !bowler.bowler || !bowler.bowler.id) return;
            
            const bowlerId = String(bowler.bowler.id || "");
            const bowlerName = bowler.bowler.name || "";
            
            if (!bowlerId || !bowlerName) return;
            
            // Get or create proper player ID to prevent duplicates
            const canonicalId = getOrCreatePlayer(bowlerId, bowlerName);
            
            if (!canonicalId || !playerStats[canonicalId]) return;
            
            // Initialize match score for this player if it doesn't exist
            matchPlayerScores[canonicalId] = matchPlayerScores[canonicalId] || 0;
            
            // Initialize per-match stats tracking if it doesn't exist
            if (!playerStats[canonicalId].matchStats) {
                playerStats[canonicalId].matchStats = {};
            }
            
            // Initialize this match's stats if they don't exist
            if (!playerStats[canonicalId].matchStats[matchId]) {
                playerStats[canonicalId].matchStats[matchId] = {
                    runs: 0,
                    balls_faced: 0,
                    wickets: 0,
                    wicket_bowled: 0,
                    wicket_lbw: 0,
                    wicket_caught: 0,
                    wicket_stumped: 0,
                    wicket_other: 0,
                    balls_bowled: 0,
                    catches: 0,
                    run_outs: 0,
                    economy: 0,
                    high_score: 0,
                    strike_rate: 0,
                    runs_conceded: 0,
                    dot_balls: 0,
                    good_ones: 0
                };
            }
            
            // Get reference to this match's stats
            const matchStats = playerStats[canonicalId].matchStats[matchId];
            
            // Parse bowling stats
            const overs = parseFloat(bowler.o || 0);
            const wickets = parseInt(bowler.w || 0);
            const runsConceded = parseInt(bowler.r || 0);
            const economy = parseFloat(bowler.eco || 0);
            const wides = parseInt(bowler.wd || 0);
            const noBalls = parseInt(bowler.nb || 0);
            
            // Calculate balls bowled (6 balls per over)
            const completedOvers = Math.floor(overs);
            const partialOver = (overs - completedOvers) * 10;
            const ballsBowled = completedOvers * 6 + partialOver;
            
            // Update overall stats
            playerStats[canonicalId].wickets += wickets;
            playerStats[canonicalId].balls_bowled += ballsBowled;
            playerStats[canonicalId].runs_conceded += runsConceded;
            
            // Update match-specific stats
            matchStats.wickets += wickets;
            matchStats.balls_bowled += ballsBowled;
            matchStats.runs_conceded += runsConceded;
            matchStats.economy = economy;
            
            // Estimate dot balls using the formula: max(balls_bowled - runs_conceded / 2, 0)
            const estimatedDotBalls = Math.max(0, ballsBowled - runsConceded / 2);
            matchStats.dot_balls += Math.round(estimatedDotBalls);
            playerStats[canonicalId].dot_balls += Math.round(estimatedDotBalls);
            
            // Calculate economy for overall stats
            if (playerStats[canonicalId].balls_bowled >= 6) {
                const totalOvers = Math.floor(playerStats[canonicalId].balls_bowled / 6) + 
                    (playerStats[canonicalId].balls_bowled % 6) / 10;
                playerStats[canonicalId].economy = 
                    playerStats[canonicalId].runs_conceded / totalOvers;
            }
            
            // Calculate bowling score
            // Formula: 3 * (1.5 * balls - runs) + 20 * wickets + 10 * good_ones + dot_balls + (wickets >= 3 ? 15 : 0)
            // Note: We now calculate good_ones as the sum of wicket_bowled and wicket_lbw
            const economyBonus = 3 * (1.5 * ballsBowled - runsConceded);
            const wicketsBonus = wickets * 20;
            const goodOnes = playerStats[canonicalId].wicket_bowled + playerStats[canonicalId].wicket_lbw;
            const goodOnesBonus = goodOnes * 10;
            const dotBallsBonus = Math.round(estimatedDotBalls);
            const threeWicketBonus = (wickets >= 3) ? 15 : 0;
            
            const bowlingScore = economyBonus + wicketsBonus + goodOnesBonus + dotBallsBonus + threeWicketBonus;
            
            // Update player's score for this match
            matchPlayerScores[canonicalId] += bowlingScore;
            
            console.log(`Added bowling stats for ${bowlerName}: ${wickets} wickets (${runsConceded} runs), score contribution: ${bowlingScore.toFixed(2)}`);
        }
        
        // Process fielder stats
        function processFielder(fielder, matchId, matchPlayerScores) {
            if (!fielder || !fielder.catcher || !fielder.catcher.id) return;
            
            const fielderId = String(fielder.catcher.id || "");
            const fielderName = fielder.catcher.name || "";
            
            if (!fielderId || !fielderName) return;
            
            // Get or create proper player ID to prevent duplicates
            const canonicalId = getOrCreatePlayer(fielderId, fielderName);
            
            if (!canonicalId || !playerStats[canonicalId]) return;
            
            // Initialize match score for this player if it doesn't exist
            matchPlayerScores[canonicalId] = matchPlayerScores[canonicalId] || 0;
            
            // Initialize per-match stats tracking if it doesn't exist
            if (!playerStats[canonicalId].matchStats) {
                playerStats[canonicalId].matchStats = {};
            }
            
            // Initialize this match's stats if they don't exist
            if (!playerStats[canonicalId].matchStats[matchId]) {
                playerStats[canonicalId].matchStats[matchId] = {
                    runs: 0,
                    balls_faced: 0,
                    wickets: 0,
                    balls_bowled: 0,
                    catches: 0,
                    run_outs: 0,
                    economy: 0,
                    high_score: 0,
                    strike_rate: 0,
                    runs_conceded: 0,
                    dot_balls: 0,
                    good_ones: 0
                };
            }
            
            // Get reference to this match's stats
            const matchStats = playerStats[canonicalId].matchStats[matchId];
            
            // Get fielding contributions
            // IMPORTANT: Skip catches as they're already processed in processBatsman
            // Only process run outs here to avoid double counting
            const runOuts = parseInt(fielder.runout || 0);
            
            // Update overall stats - only update run outs, not catches
            playerStats[canonicalId].run_outs += runOuts;
            
            // Update match-specific stats - only update run outs, not catches
            matchStats.run_outs += runOuts;
            
            // We no longer add points here as they will be calculated in calculateMatchScore
            
            console.log(`Added fielding stats for ${fielderName}: ${runOuts} run outs`);
        }
        
        // Helper to extract catcher ID - not needed with the scorecard API
        function getCatcherId(ball) {
            // This function is no longer used with the scorecard API
            return null;
        }
        
        // Function to get existing player or create a new one, preventing duplicates
        function getOrCreatePlayer(playerId, playerName) {
            if (!playerName) return playerId;
            
            // Normalize player name for case-insensitive matching
            const normalizedName = playerName.trim().toLowerCase();
            
            // Check if we've seen this player name before
            if (playerNameToId[normalizedName]) {
                // We have this player already with a different ID
                const existingId = playerNameToId[normalizedName];
                
                if (existingId !== playerId) {
                    console.log(`Found duplicate player! ${playerName} has IDs: ${existingId} and ${playerId}`);
                    
                    // If we have stats for this new ID, merge them into the existing player
                    if (playerStats[playerId]) {
                        mergePlayerStats(existingId, playerId);
                        // Delete the duplicate entry
                        delete playerStats[playerId];
                    }
                }
                
                // Return the canonical ID for this player
                return existingId;
            }
            
            // Check for common name variations (e.g., "V Kohli" vs "Virat Kohli")
            // This helps match players across different formats in the API
            const matchedId = findPlayerByNameVariation(normalizedName);
            if (matchedId) {
                playerNameToId[normalizedName] = matchedId;
                return matchedId;
            }
            
            // Check for existing player in team mapping by ID
            if (teamOwnerMapping[playerId]) {
                playerNameToId[normalizedName] = playerId;
                return playerId;
            }
            
            // Check if player exists in team mapping by name
            let foundId = null;
            for (const [id, info] of Object.entries(teamOwnerMapping)) {
                if (info.player_name.toLowerCase() === normalizedName) {
                    foundId = id;
                    break;
                }
            }
            
            if (foundId) {
                playerNameToId[normalizedName] = foundId;
                
                // If we have stats for the API ID, merge them into the CSV ID
                if (playerStats[playerId] && playerId !== foundId) {
                    mergePlayerStats(foundId, playerId);
                    // Delete the duplicate entry
                    delete playerStats[playerId];
                }
                
                return foundId;
            }
            
            // This is a new player not in our CSV
            // Create player record if it doesn't exist
            if (!playerStats[playerId]) {
                const ownerInfo = findOwnerByName(playerName);
                playerStats[playerId] = {
                    player_id: playerId,
                    player_name: playerName,
                    team_id: ownerInfo.team_id || "",
                    owner: ownerInfo.owner || "Unknown",
                    extra_mult: ownerInfo.extra_mult || 1.0, // Get multiplier from owner info if available
                    runs: 0,
                    balls_faced: 0,
                    wickets: 0,
                    wicket_bowled: 0,
                    wicket_lbw: 0,
                    wicket_caught: 0,
                    wicket_stumped: 0,
                    wicket_other: 0,
                    balls_bowled: 0,
                    catches: 0,
                    run_outs: 0,
                    economy: 0,
                    high_score: 0,
                    strike_rate: 0,
                    runs_conceded: 0,
                    dot_balls: 0,
                    good_ones: 0,
                    score: 0,
                    matchScores: {}, // Track scores per match
                    matchStats: {},   // Track stats per match
                    multiplier_count: 0 // Track how many times player got 1.3x multiplier
                };
                console.log(`Added new player: ${playerName} (${playerId})`);
            }
            
            // Register this player
            playerNameToId[normalizedName] = playerId;
            return playerId;
        }
        
        // Helper function to find players by name variations
        function findPlayerByNameVariation(normalizedName) {
            // Common abbreviations and variations
            // For example, "V Kohli" should match "Virat Kohli"
            for (const [id, info] of Object.entries(teamOwnerMapping)) {
                const fullName = info.player_name.toLowerCase();
                
                // Case 1: Full name in mapping matches part of the name from API
                if (normalizedName.includes(fullName)) {
                    return id;
                }
                
                // Case 2: First initial + last name (e.g. "V Kohli" for "Virat Kohli")
                const nameParts = fullName.split(' ');
                if (nameParts.length >= 2) {
                    const lastName = nameParts[nameParts.length - 1];
                    const firstInitial = nameParts[0][0];
                    
                    // Check if the name matches pattern "F Lastname" (e.g. "V Kohli")
                    const initialLastNamePattern = `${firstInitial} ${lastName}`;
                    if (normalizedName === initialLastNamePattern) {
                        return id;
                    }
                    
                    // Check if last name matches and it's a unique last name
                    if (normalizedName.includes(lastName) && lastName.length > 3) {
                        // Check if this last name is unique enough
                        let lastNameCount = 0;
                        for (const otherInfo of Object.values(teamOwnerMapping)) {
                            if (otherInfo.player_name.toLowerCase().includes(lastName)) {
                                lastNameCount++;
                            }
                        }
                        
                        // If this last name is unique in our mapping, use it
                        if (lastNameCount === 1) {
                            return id;
                        }
                    }
                }
            }
            
            return null;
        }
        
        // Function to merge stats from sourceId into targetId
        function mergePlayerStats(targetId, sourceId) {
            if (!playerStats[targetId] || !playerStats[sourceId]) return;
            
            console.log(`Merging player stats from ${sourceId} to ${targetId}`);
            
            const target = playerStats[targetId];
            const source = playerStats[sourceId];
            
            // Merge numerical stats
            target.runs += source.runs;
            target.balls_faced += source.balls_faced;
            target.wickets += source.wickets;
            target.wicket_bowled += source.wicket_bowled || 0;
            target.wicket_lbw += source.wicket_lbw || 0;
            target.wicket_caught += source.wicket_caught || 0;
            target.wicket_stumped += source.wicket_stumped || 0;
            target.wicket_other += source.wicket_other || 0;
            target.balls_bowled += source.balls_bowled;
            target.catches += source.catches;
            target.run_outs += source.run_outs;
            target.runs_conceded += source.runs_conceded;
            target.dot_balls += source.dot_balls;
            target.good_ones += source.good_ones;
            
            // Update high score if needed
            if (source.high_score > target.high_score) {
                target.high_score = source.high_score;
            }
            
            // Recalculate strike rate
            if (target.balls_faced > 0) {
                target.strike_rate = (target.runs / target.balls_faced) * 100;
            }
            
            // Recalculate economy
            if (target.balls_bowled >= 6) {
                const overs = Math.floor(target.balls_bowled / 6) + (target.balls_bowled % 6) / 10;
                target.economy = target.runs_conceded / overs;
            }
            
            console.log(`Merged stats for ${target.player_name}`);
        }
        
        // Helper function to find owner info by player name
        function findOwnerByName(playerName) {
            if (!playerName) return { owner: "Unknown", team_id: "", extra_mult: 1.0 };
            
            // Look for exact name matches first
            for (const [playerId, info] of Object.entries(teamOwnerMapping)) {
                if (info.player_name.toLowerCase() === playerName.toLowerCase()) {
                    console.log(`Found exact owner match for: ${playerName} -> ${info.owner}`);
                    return { 
                        owner: info.owner, 
                        team_id: info.team_id,
                        extra_mult: info.extra_mult || 1.0
                    };
                }
            }
            
            // No special cases - just return Unknown if no match found
            return { owner: "Unknown", team_id: "", extra_mult: 1.0 };
        }
        
        // Calculate scores for all players
        function calculateAllScores() {
            console.log("Calculating all player scores...");
            // Calculate each player's score
            for (const playerId in playerStats) {
                const player = playerStats[playerId];
                
                // Reset score
                player.score = 0;
                
                // Calculate score for each match and sum
                for (const matchId in player.matchStats) {
                    const matchStats = player.matchStats[matchId];
                    
                    // Calculate base score for this match
                    const matchScore = calculateMatchScore(matchStats);
                    
                    // Apply 1.3x multiplier if this player was the highest scorer in the match
                    let finalMatchScore = matchScore;
                    if (matchStats.is_highest_scorer) {
                        finalMatchScore = matchScore * 1.3;
                        
                        // Count this multiplier for display
                        player.multiplier_count = (player.multiplier_count || 0) + 1;
                    }
                    
                    // Apply the extra multiplier (from teams.csv)
                    finalMatchScore = finalMatchScore * player.extra_mult;
                    
                    // Add this match's score to total
                    player.score += finalMatchScore;
                }
                
                // Round to 2 decimal places
                player.score = Math.round(player.score * 100) / 100;
            }
        }
        
        // Function to calculate a player's score for a single match
        function calculateMatchScore(stats) {
            // Batting score
            let batsman_score = 0;
            if (stats.balls_faced > 0) {
                const sr = stats.runs / stats.balls_faced;
                batsman_score = stats.runs + (sr - 1.5) * Math.max(stats.runs, stats.balls_faced) + 
                              (stats.runs >= 50 ? 8 : 0) + (stats.runs >= 100 ? 8 : 0);
            }
            
            // Bowling score
            let bowlers_score = 0;
            if (stats.balls_bowled > 0) {
                // Calculate good ones as the sum of bowled and lbw dismissals
                const good_ones = stats.wicket_bowled + stats.wicket_lbw;
                
                bowlers_score = 3 * (1.5 * stats.balls_bowled - stats.runs_conceded) + 
                              stats.wickets * 20 + good_ones * 10 + 
                              (stats.wickets >= 3 ? 15 : 0) + stats.dot_balls;
            }
            
            // Fielding score (catches, stumpings, and run-outs)
            const stumpings = stats.stumpings || 0;
            const fielding_score = (stats.catches + stats.run_outs + stumpings) * 10;
            
            // Final score for this match
            return batsman_score + bowlers_score + fielding_score + 4;
        }

        // Function to display player table
        function displayPlayerTable() {
            console.log("Displaying player table");
            const container = document.getElementById('player-table-container');
            
            // Get all players and sort by score (descending), excluding players with "Unknown" owner
            const players = Object.values(playerStats)
                .filter(player => player.owner !== "Unknown")
                .sort((a, b) => b.score - a.score);
            
            // Create table HTML
            let tableHtml = `
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Owner</th>
                            <th>Runs</th>
                            <th>Balls</th>
                            <th>Wickets</th>
                            <th>Field</th>
                            <th>1.3</th>
                            <th>Mult</th>
                            <th>Score</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Add player rows
            players.forEach((player, index) => {
                // Add a highlight for players who got the multiplier
                const rowClass = player.multipliedMatches && player.multipliedMatches.length > 0 ? 
                    'style="background-color: #ffffd0;"' : '';
                
                // Show multiplier count instead of just a star
                const multiplierCount = player.multiplier_count || 0;
                
                // Get stumpings or default to 0
                const stumpings = player.stumpings || 0;
                
                // Combine stumpings, catches and run outs
                const fieldingContributions = stumpings + player.catches + player.run_outs;
                
                // Format extra multiplier display
                const extraMultDisplay = player.extra_mult !== 1.0 ? `${player.extra_mult.toFixed(1)}` : '-';
                
                tableHtml += `
                    <tr ${rowClass}>
                        <td>${index + 1}</td>
                        <td>${player.player_name}</td>
                        <td>${player.owner}</td>
                        <td>${player.runs}</td>
                        <td>${player.balls_faced}</td>
                        <td>${player.wickets}</td>
                        <td>${fieldingContributions}</td>
                        <td>${multiplierCount}</td>
                        <td>${extraMultDisplay}</td>
                        <td><strong>${player.score}</strong></td>
                    </tr>
                `;
            });
            
            tableHtml += `
                    </tbody>
                </table>
                <div class="stats-info">
                    Matches processed: ${matchesProcessed} | Players: ${players.length}
                </div>
            `;
            
            // Update the container
            container.innerHTML = tableHtml;
        }

        // Function to display the team dashboard
        function displayTeamDashboard() {
            console.log("Displaying team dashboard");
            const container = document.getElementById('team-dashboard');
            
            // Group players by owner
            const teamData = {};
            
            // Collect player data by owner
            for (const playerId in playerStats) {
                const player = playerStats[playerId];
                const owner = player.owner || "";
                
                // Skip players with Unknown owner
                if (owner === "Unknown") continue;
                
                if (!teamData[owner]) {
                    teamData[owner] = {
                        owner: owner,
                        players: [],
                        totalScore: 0
                    };
                }
                
                teamData[owner].players.push(player);
                teamData[owner].totalScore += player.score;
            }
            
            // Convert to array and sort by total score
            const teams = Object.values(teamData).sort((a, b) => b.totalScore - a.totalScore);
            
            // Create dashboard HTML
            let dashboardHtml = `
                <h2 style="text-align: center;">Team Dashboard</h2>
                <div class="accordion-container">
            `;
            
            teams.forEach((team, index) => {
                // Sort team players by score
                team.players.sort((a, b) => b.score - a.score);
                
                // Get the top player (highest scorer)
                const topPlayer = team.players[0];
                
                // Calculate number of multiplier bonuses in the team
                const teamMultiplierCount = team.players.reduce((sum, player) => sum + (player.multiplier_count || 0), 0);
                
                // Create unique ID for each team's content
                const teamId = `team-${index}`;
                
                dashboardHtml += `
                    <div class="team-accordion">
                        <div class="team-header" onclick="toggleTeamDetails('${teamId}')">
                            <div>
                                <h3>${index + 1}. ${team.owner} - ${team.totalScore} points</h3>
                                <p class="team-summary">
                                    ${team.players.length} players | 
                                    Top: ${topPlayer ? topPlayer.player_name + ' (' + topPlayer.score + ')' : 'None'} | 
                                    Total 1.3 bonuses: ${teamMultiplierCount}
                                </p>
                            </div>
                            <span class="expand-icon" id="${teamId}-icon">+</span>
                        </div>
                        <div class="team-content" id="${teamId}" style="display: none;">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Player</th>
                                        <th>1.3</th>
                                        <th>Mult</th>
                                        <th>Score</th>
                                    </tr>
                                </thead>
                                <tbody>
                `;
                
                team.players.forEach(player => {
                    // Show multiplier count
                    const multiplierCount = player.multiplier_count || 0;
                    
                    // Format extra multiplier display
                    const extraMultDisplay = player.extra_mult !== 1.0 ? `${player.extra_mult.toFixed(1)}` : '-';
                    
                    dashboardHtml += `
                        <tr>
                            <td>${player.player_name}</td>
                            <td>${multiplierCount}</td>
                            <td>${extraMultDisplay}</td>
                            <td><strong>${player.score}</strong></td>
                        </tr>
                    `;
                });
                
                dashboardHtml += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            });
            
            dashboardHtml += `
                </div>
            `;
            
            // Update the container
            container.innerHTML = dashboardHtml;
        }

        // Function to toggle team details visibility
        function toggleTeamDetails(teamId) {
            const content = document.getElementById(teamId);
            const icon = document.getElementById(`${teamId}-icon`);
            
            if (content.style.display === "none") {
                content.style.display = "block";
                icon.textContent = "-";
                icon.classList.add("open");
            } else {
                content.style.display = "none";
                icon.textContent = "+";
                icon.classList.remove("open");
            }
        }

        // Function to search for a player's match history
        function searchPlayerMatches() {
            const playerName = document.getElementById('player-search-input').value.trim();
            const container = document.getElementById('player-matches-container');
            
            if (!playerName) {
                container.innerHTML = `<div class="error">Please enter a player name to search</div>`;
                return;
            }
            
            // Find player by name (case insensitive), excluding Unknown owner players
            const normalizedSearchName = playerName.toLowerCase();
            let foundPlayer = null;
            
            for (const playerId in playerStats) {
                const player = playerStats[playerId];
                if (player.owner !== "Unknown" && player.player_name.toLowerCase().includes(normalizedSearchName)) {
                    foundPlayer = player;
                    break;
                }
            }
            
            if (!foundPlayer) {
                container.innerHTML = `<div class="error">No player found with name "${playerName}"</div>`;
                return;
            }
            
            // Display player's match history
            displayPlayerMatchHistory(foundPlayer);
        }

        // Function to display a player's match history
        function displayPlayerMatchHistory(player) {
            const container = document.getElementById('player-matches-container');
            
            // Format extra multiplier display
            const extraMultDisplay = player.extra_mult !== 1.0 ? ` (${player.extra_mult.toFixed(1)} extra multiplier)` : '';
            const multiplierCountDisplay = player.multiplier_count > 0 ? ` (${player.multiplier_count} got 1.3 match bonus)` : '';
            
            let historyHtml = `
                <h2>${player.player_name}'s Match History${extraMultDisplay}${multiplierCountDisplay}</h2>
                <div class="stats-info">Owner: ${player.owner} | Total Score: ${player.score}</div>
            `;
            
            if (!player.matchStats || Object.keys(player.matchStats).length === 0) {
                historyHtml += `<div class="error">No match data found for this player</div>`;
                container.innerHTML = historyHtml;
                return;
            }
            
            // Sort matches by date (assuming match IDs are somewhat chronological)
            const matchIds = Object.keys(player.matchStats).sort();
            
            // Create a table showing all matches with detailed stats
            historyHtml += `
                <table>
                    <thead>
                        <tr>
                            <th>Match</th>
                            <th>Runs</th>
                            <th>Balls</th>
                            <th>SR</th>
                            <th>Wickets</th>
                            <th>Conceded</th>
                            <th>Good</th>
                            <th>Dots</th>
                            <th>S+C</th>
                            <th>RO</th>
                            <th>Bonus</th>
                            <th>Score</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            matchIds.forEach((matchId, index) => {
                const matchStats = player.matchStats[matchId];
                const matchScore = player.matchScores[matchId] || 0;
                
                // Check if player got multiplier for this match
                const gotMultiplier = player.multipliedMatches && player.multipliedMatches.includes(matchId);
                const multiplierIcon = gotMultiplier ? '' : '';
                
                // Calculate good_ones as the sum of bowled and LBW wickets
                const good_ones = matchStats.wicket_bowled + matchStats.wicket_lbw;
                
                // Get stumpings or default to 0
                const stumpings = matchStats.stumpings || 0;
                
                // Combine stumpings and catches
                const stumpingsAndCatches = stumpings + matchStats.catches;
                
                // Calculate strike rate with proper formatting
                const strikeRate = matchStats.balls_faced > 0 
                    ? (matchStats.runs / matchStats.balls_faced * 100).toFixed(2) 
                    : '-';
                
                // Determine row class for highlighting
                const rowClass = gotMultiplier ? 'style="background-color: #ffffd0;"' : '';
                
                historyHtml += `
                    <tr ${rowClass}>
                        <td>Match ${index + 1}</td>
                        <td>${matchStats.runs}</td>
                        <td>${matchStats.balls_faced}</td>
                        <td>${strikeRate}</td>
                        <td>${matchStats.wickets}</td>
                        <td>${matchStats.runs_conceded}</td>
                        <td>${good_ones}</td>
                        <td>${matchStats.dot_balls}</td>
                        <td>${stumpingsAndCatches}</td>
                        <td>${matchStats.run_outs}</td>
                        <td>${multiplierIcon}</td>
                        <td><strong>${matchScore.toFixed(0)}</strong></td>
                    </tr>
                `;
            });
            
            historyHtml += `
                    </tbody>
                </table>
            `;
            
            // Add additional detailed view below the table
            historyHtml += `<h3>Match Details</h3>`;
            
            matchIds.forEach((matchId, index) => {
                const matchStats = player.matchStats[matchId];
                const matchScore = player.matchScores[matchId] || 0;
                
                // Check if player got multiplier for this match
                const gotMultiplier = player.multipliedMatches && player.multipliedMatches.includes(matchId);
                const multiplierIcon = gotMultiplier ? ' (1.3 bonus applied)' : '';
                
                // Calculate good_ones as the sum of bowled and LBW wickets
                const good_ones = matchStats.wicket_bowled + matchStats.wicket_lbw;
                
                // Get stumpings or default to 0
                const stumpings = matchStats.stumpings || 0;
                
                historyHtml += `
                    <div class="match-card">
                        <h3>Match ${index + 1} ${multiplierIcon}</h3>
                        <div class="match-details">
                            <div class="stat-box">
                                <h4>Batting</h4>
                                <p>Runs: ${matchStats.runs}</p>
                                <p>Balls: ${matchStats.balls_faced}</p>
                                <p>SR: ${matchStats.strike_rate ? matchStats.strike_rate.toFixed(2) : '-'}</p>
                            </div>
                            <div class="stat-box">
                                <h4>Bowling</h4>
                                <p>Wickets: ${matchStats.wickets}</p>
                                <p>Good ones (B+LBW): ${good_ones}</p>
                                <p>Bowled: ${matchStats.wicket_bowled}</p>
                                <p>LBW: ${matchStats.wicket_lbw}</p>
                                <p>Caught: ${matchStats.wicket_caught}</p>
                                <p>Stumped: ${matchStats.wicket_stumped}</p>
                                <p>Conceded: ${matchStats.runs_conceded}</p>
                                <p>Dots: ${matchStats.dot_balls}</p>
                                <p>Balls bowled: ${matchStats.balls_bowled}</p>
                            </div>
                            <div class="stat-box">
                                <h4>Fielding</h4>
                                <p>Catches: ${matchStats.catches}</p>
                                <p>Stumpings: ${stumpings}</p>
                                <p>Run Outs: ${matchStats.run_outs}</p>
                            </div>
                            <div class="stat-box">
                                <h4>Score Breakdown</h4>
                                <p>Base: ${(matchScore / (gotMultiplier ? 1.3 : 1)).toFixed(2)}</p>
                                ${gotMultiplier ? `<p>Multiplier: 1.3</p>` : ''}
                                <p><strong>Final: ${matchScore.toFixed(2)}</strong></p>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = historyHtml;
        }

        // Function to show the selected tab
        function showTab(tabId) {
            console.log(`Showing tab: ${tabId}`);
            
            // Hide all tabs first with display: none
            document.getElementById('player-table-container').style.display = 'none';
            document.getElementById('team-dashboard').style.display = 'none';
            document.getElementById('player-matches').style.display = 'none';
            
            // Show the selected tab with display: block
            if (tabId === 'player-table-container') {
                document.getElementById('player-table-container').style.display = 'block';
            } else if (tabId === 'team-dashboard') {
                document.getElementById('team-dashboard').style.display = 'block';
                // Always refresh team dashboard when showing it
                displayTeamDashboard();
            } else if (tabId === 'player-matches') {
                document.getElementById('player-matches').style.display = 'block';
            }
            
            // Update active tab button
            const buttons = document.querySelectorAll('.nav-btn');
            buttons.forEach(button => {
                button.classList.remove('tab-active');
                if (button.getAttribute('onclick').includes(tabId)) {
                    button.classList.add('tab-active');
                }
            });
        }

        // New function to set extra multipliers for players
        function setExtraMultipliers() {
            console.log("Using multipliers from teams.csv file");
            // We don't need to set any multipliers manually now
            // They are loaded from the CSV file
        }

        // Check for key parameter on page load
        window.addEventListener('DOMContentLoaded', function() {
            const urlParams = new URLSearchParams(window.location.search);
            if (!urlParams.has('key')) {
                console.warn("No 'key' parameter found in URL. The API calls may fail.");
                document.getElementById('main-container').innerHTML = `
                    <div style="text-align:center; padding:30px; background-color:#fff3cd; border-radius:5px; margin:20px auto; max-width:600px;">
                        <h3> Missing API Key Suffix</h3>
                        <p>You need to add the last 4 characters of the API key as a URL parameter.</p>
                        <p>Example: <code>?key=477a</code></p>
                        <p>Please add the parameter to the URL and reload the page.</p>
                    </div>
                `;
            }
        });
    </script>
</body>
</html> 