<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Cricket Stats</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        .table {
            margin-top: 20px;
        }
        #loadingMessage {
            display: none;
            margin: 20px 0;
        }
        #results {
            display: none;
        }
        .input-group {
            max-width: 600px;
            margin: 0 auto;
        }
        h1 {
            margin-bottom: 30px;
            color: #333;
        }
        .alert {
            max-width: 600px;
            margin: 20px auto;
        }
        .table th {
            background-color: #f8f9fa;
        }
        .table-striped tbody tr:nth-of-type(odd) {
            background-color: rgba(0,0,0,.02);
        }
        .star {
            color: gold;
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center">Cricket Stats</h1>
        
        <div id="loadingMessage" class="alert alert-info text-center">
            Loading data from CricAPI...
        </div>
        
        <div id="results"></div>
    </div>

    <script>
        // Full API key with last 4 characters matching the URL parameter
        const FULL_API_KEY = "282bffef-9065-43b3-91f0-df54dec227fd";
        
        // Add timestamp to prevent caching
        function addTimestamp(url) {
            return `${url}${url.includes('?') ? '&' : '?'}_t=${Date.now()}`;
        }

        // Auto refresh every 5 minutes
        setInterval(() => {
            window.location.reload();
        }, 300000);
        
        // Start fetching data immediately
        document.getElementById('loadingMessage').style.display = 'block';
        document.getElementById('results').style.display = 'none';
        fetchData(FULL_API_KEY);

        // IPL 2025 Series ID
        const IPL_2025_SERIES_ID = "d5a498c8-7596-4b93-8ab0-e0efc3345312";
        
        async function fetchData(apiKey) {            
            document.getElementById('loadingMessage').textContent = 'Loading data from CricAPI...';
            
            try {
                // Fetch series matches first to validate API key
                const matches = await fetchSeriesMatches(apiKey, IPL_2025_SERIES_ID);
                if (!matches || matches.length === 0) {
                    throw new Error('No matches found for IPL 2025');
                }
                
                // Fetch team owner mapping
                const teamOwnerMapping = await fetchTeamOwnerMapping();
                
                // Process each match
                const matchStats = {};
                for (const match of matches) {
                    document.getElementById('loadingMessage').textContent = `Loading match details for ${match.name}...`;
                    const matchDetails = await fetchMatchDetails(apiKey, match.id);
                    processMatchDetails(matchDetails, match.id, teamOwnerMapping, matchStats);
                }
                
                // Calculate owner stats
                const ownerStats = calculateOwnerStats(matchStats, teamOwnerMapping);
                
                // Display results
                displayResults(ownerStats);
                
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('results').style.display = 'block';
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('loadingMessage').innerHTML = `
                    <div class="alert alert-danger">
                        Error: ${error.message}
                    </div>
                `;
            }
        }
        
        async function fetchTeamOwnerMapping() {
            try {
                // Try GitHub Pages path first with timestamp
                const response = await fetch(addTimestamp('/ipl-dv/teams.csv'), {
                    cache: 'no-store',
                    headers: {
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    }
                });
                if (!response.ok) {
                    throw new Error('Failed to load teams.csv');
                }
                const text = await response.text();
                return parseTeamOwnerMapping(text);
            } catch (error) {
                // Fallback to local path with timestamp
                try {
                    const response = await fetch(addTimestamp('teams.csv'), {
                        cache: 'no-store',
                        headers: {
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache'
                        }
                    });
                    if (!response.ok) {
                        throw new Error('Failed to load teams.csv');
                    }
                    const text = await response.text();
                    return parseTeamOwnerMapping(text);
                } catch (secondError) {
                    throw new Error('Could not load team ownership data. Please check if teams.csv exists.');
                }
            }
        }

        function parseTeamOwnerMapping(csvText) {
            const lines = csvText.split('\n');
            const mapping = {};
            
            // Skip header row
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(s => s.trim());
                if (values.length >= 4) {
                    const [player_id, player_name, team_id, owner] = values;
                    if (player_id && owner) {
                        mapping[player_id] = { player_name, team_id, owner };
                    }
                }
            }
            
            return mapping;
        }
        
        async function fetchSeriesMatches(apiKey, seriesId) {
            try {
                // Add timestamp to prevent caching
                const response = await fetch(addTimestamp(`https://api.cricapi.com/v1/series_info?apikey=${apiKey}&id=${seriesId}`), {
                    cache: 'no-store',
                    headers: {
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    }
                });
                const data = await response.json();
                console.log('Series API Response:', data); // Debug log
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                if (data.status !== "success") {
                    throw new Error(data.info || data.error || 'API returned unsuccessful status');
                }
                
                // Get only started matches from this series
                const matches = (data.data?.matchList || []).filter(match => match.matchStarted === true);
                if (matches.length === 0) {
                    throw new Error('No started IPL 2025 matches found');
                }

                console.log('Started IPL 2025 matches:', matches); // Debug log
                return matches;
            } catch (error) {
                console.error('Series API Error:', error);
                throw new Error(`Failed to fetch series matches: ${error.message}`);
            }
        }
        
        async function fetchMatchDetails(apiKey, matchId) {
            try {
                // Add timestamp to prevent caching
                const response = await fetch(addTimestamp(`https://api.cricapi.com/v1/match_bbb?apikey=${apiKey}&id=${matchId}`), {
                    cache: 'no-store',
                    headers: {
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    }
                });
                const data = await response.json();
                console.log('Match API Response:', data); // Debug log
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                if (data.status !== "success") {
                    throw new Error(data.info || data.error || 'API returned unsuccessful status');
                }
                
                return data;
            } catch (error) {
                console.error('Match API Error:', error);
                throw new Error(`Failed to fetch match details: ${error.message}`);
            }
        }
        
        function processMatchDetails(matchData, matchId, teamOwnerMapping, matchStats) {
            const data = matchData.data || matchData;
            let ballByBall = data.ballByBall || data.bbb || [];
            
            if (!ballByBall || !ballByBall.length) {
                return;
            }
            
            // Initialize match stats if needed
            if (!matchStats[matchId]) {
                matchStats[matchId] = {};
            }
            
            // Process each ball
            ballByBall.forEach(inning => {
                if (inning.overs) {
                    // Process each over
                    inning.overs.forEach(over => {
                        // Process each ball
                        over.balls.forEach(ball => {
                            processBall(ball, matchId, matchStats[matchId]);
                        });
                    });
                } else {
                    // If it's a flat list of balls
                    processBall(inning, matchId, matchStats[matchId]);
                }
            });
        }
        
        function processBall(ball, matchId, matchStats) {
            const batter = ball.batter || ball.batsman || {};
            const bowler = ball.bowler || {};
            
            const batterId = batter.id;
            const bowlerId = bowler.id;
            
            if (!batterId || !bowlerId) return;
            
            // Initialize player stats if needed
            [batterId, bowlerId].forEach(playerId => {
                if (!matchStats[playerId]) {
                    matchStats[playerId] = {
                        name: playerId === batterId ? batter.name : bowler.name,
                        runs: 0,
                        balls: 0,
                        bowled_balls: 0,
                        runs_conceded: 0,
                        wickets: 0,
                        wicket_bowled_or_lbw: 0,
                        catches: 0,
                        run_outs: 0,
                        match_id: matchId
                    };
                }
            });
            
            // Update batter stats
            const batterStats = matchStats[batterId];
            const runs = (ball.runs?.batter || ball.runs || 0);
            batterStats.runs += runs;
            batterStats.balls += 1;
            
            // Update bowler stats
            const bowlerStats = matchStats[bowlerId];
            bowlerStats.bowled_balls += 1;
            bowlerStats.runs_conceded += (ball.runs?.total || ball.runs || 0);
            
            // Handle wickets
            if (ball.isWicket || ball.wicket) {
                const wicket = ball.wicket || {};
                const wicketType = wicket.type;
                
                if (['bowled', 'caught', 'lbw', 'stumped', 'caught and bowled', 'hit wicket'].includes(wicketType)) {
                    bowlerStats.wickets += 1;
                    
                    if (['bowled', 'lbw', 'caught and bowled'].includes(wicketType)) {
                        bowlerStats.wicket_bowled_or_lbw += 1;
                    }
                }
                
                // Handle catches
                if (wicketType === 'caught') {
                    const fielder = (wicket.fielders || [])[0] || {};
                    const fielderId = fielder.id;
                    
                    if (fielderId) {
                        if (!matchStats[fielderId]) {
                            matchStats[fielderId] = {
                                name: fielder.name,
                                runs: 0,
                                balls: 0,
                                bowled_balls: 0,
                                runs_conceded: 0,
                                wickets: 0,
                                wicket_bowled_or_lbw: 0,
                                catches: 0,
                                run_outs: 0,
                                match_id: matchId
                            };
                        }
                        matchStats[fielderId].catches += 1;
                    }
                }
                
                // Handle run outs
                if (wicketType === 'run out') {
                    (wicket.fielders || []).forEach(fielder => {
                        const fielderId = fielder.id;
                        if (fielderId) {
                            if (!matchStats[fielderId]) {
                                matchStats[fielderId] = {
                                    name: fielder.name,
                                    runs: 0,
                                    balls: 0,
                                    bowled_balls: 0,
                                    runs_conceded: 0,
                                    wickets: 0,
                                    wicket_bowled_or_lbw: 0,
                                    catches: 0,
                                    run_outs: 0,
                                    match_id: matchId
                                };
                            }
                            matchStats[fielderId].run_outs += 1;
                        }
                    });
                }
            }
        }
        
        function calculateOwnerStats(matchStats, teamOwnerMapping) {
            const ownerStats = {};
            
            // Process each match
            Object.entries(matchStats).forEach(([matchId, match]) => {
                // Calculate scores for each player in the match
                Object.entries(match).forEach(([playerId, stats]) => {
                    const score = calculatePlayerScore(stats);
                    stats.score = score;
                    
                    // Find owner info
                    const ownerInfo = teamOwnerMapping[playerId];
                    if (ownerInfo) {
                        const { owner, player_name, team_id } = ownerInfo;
                        
                        // Initialize owner entry if needed
                        if (!ownerStats[owner]) {
                            ownerStats[owner] = {
                                totalScore: 0,
                                players: []
                            };
                        }
                        
                        // Add player stats to owner's list
                        ownerStats[owner].players.push({
                            name: player_name,
                            teamId: team_id,
                            ...stats
                        });
                    }
                });
                
                // Find highest scorer in each match and apply 1.3x multiplier
                let maxScore = 0;
                let highestScorer = null;
                
                Object.entries(match).forEach(([playerId, stats]) => {
                    if (stats.score > maxScore) {
                        maxScore = stats.score;
                        highestScorer = playerId;
                    }
                });
                
                if (highestScorer) {
                    const stats = match[highestScorer];
                    stats.originalScore = stats.score;
                    stats.score *= 1.3;
                    stats.isHighestScorer = true;
                }
            });
            
            // Calculate total scores for each owner
            Object.values(ownerStats).forEach(owner => {
                owner.totalScore = owner.players.reduce((sum, player) => sum + player.score, 0);
            });
            
            return ownerStats;
        }
        
        function calculatePlayerScore(stats) {
            // Base score
            let score = 4;
            
            // Batting score
            if (stats.runs > 0) {
                score += stats.runs;
                if (stats.runs >= 50) score += 8;
                if (stats.runs >= 100) score += 8;
            }
            
            // Bowling score
            const wickets = stats.wickets;
            const goodWickets = stats.wicket_bowled_or_lbw;
            score += (goodWickets * 20) + ((wickets - goodWickets) * 16);
            if (wickets >= 3) score += 15;
            
            // Fielding score
            score += (stats.catches * 8) + (stats.run_outs * 8);
            
            return score;
        }
        
        function displayResults(ownerStats) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';
            
            // Create owner scores table
            const ownerTable = document.createElement('table');
            ownerTable.className = 'table table-striped';
            ownerTable.innerHTML = `
                <thead>
                    <tr>
                        <th>Owner</th>
                        <th>Total Score</th>
                    </tr>
                </thead>
                <tbody>
                    ${Object.entries(ownerStats)
                        .sort((a, b) => b[1].totalScore - a[1].totalScore)
                        .map(([owner, stats]) => `
                            <tr>
                                <td>${owner}</td>
                                <td>${stats.totalScore.toFixed(1)}</td>
                            </tr>
                        `).join('')}
                </tbody>
            `;
            
            // Create player scores table
            const playerTable = document.createElement('table');
            playerTable.className = 'table table-striped mt-4';
            playerTable.innerHTML = `
                <thead>
                    <tr>
                        <th>Player</th>
                        <th>Owner</th>
                        <th>Runs</th>
                        <th>Wickets</th>
                        <th>Catches</th>
                        <th>Run Outs</th>
                        <th>Score</th>
                    </tr>
                </thead>
                <tbody>
                    ${Object.entries(ownerStats)
                        .flatMap(([owner, stats]) => 
                            stats.players.map(player => `
                                <tr>
                                    <td>${player.name}${player.isHighestScorer ? '<span class="star">★</span>' : ''}</td>
                                    <td>${owner}</td>
                                    <td>${player.runs}</td>
                                    <td>${player.wickets}</td>
                                    <td>${player.catches}</td>
                                    <td>${player.run_outs}</td>
                                    <td>${player.score.toFixed(1)}</td>
                                </tr>
                            `)
                        ).join('')}
                </tbody>
            `;
            
            resultsDiv.appendChild(ownerTable);
            resultsDiv.appendChild(playerTable);
        }
    </script>
</body>
</html> 