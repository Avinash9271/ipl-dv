<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cricket Stats</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .table {
            margin-top: 20px;
        }
        #loadingMessage {
            display: none;
            margin: 20px 0;
        }
        #results {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Cricket Stats</h1>
        
        <div class="row mt-4">
            <div class="col-md-6">
                <div class="input-group">
                    <input type="text" id="apiKey" class="form-control" placeholder="Enter your CricAPI key">
                    <button class="btn btn-primary" onclick="fetchData()">Fetch Data</button>
                </div>
            </div>
        </div>
        
        <div id="loadingMessage" class="alert alert-info">
            Loading data from CricAPI...
        </div>
        
        <div id="results"></div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const statusMessage = document.getElementById('status-message');
            const dataContainer = document.getElementById('data-container');
            
            // Get API key from URL parameter
            const urlParams = new URLSearchParams(window.location.search);
            const apiKey = urlParams.get('key');
            
            if (!apiKey) {
                statusMessage.className = 'status-message error';
                statusMessage.textContent = 'Error: API key is required. Add it to the URL as ?key=YOUR_API_KEY';
                return;
            }

            // Series ID for IPL 2024
            const seriesId = "c75f8952-74d4-416f-b7b4-7da4b4e3ae6e";
            
            // Function to fetch series matches
            async function fetchSeriesMatches() {
                try {
                    const response = await fetch(`https://api.cricapi.com/v1/series_matches?apikey=${apiKey}&id=${seriesId}`);
                    const data = await response.json();
                    
                    if (data.status !== "success") {
                        throw new Error(data.message || "Failed to fetch matches");
                    }
                    
                    return data.data.matches.filter(match => match.status === "COMPLETED");
                } catch (error) {
                    throw new Error(`Error fetching matches: ${error.message}`);
                }
            }
            
            // Function to fetch match details
            async function fetchMatchDetails(matchId) {
                try {
                    const response = await fetch(`https://api.cricapi.com/v1/match_bbb?apikey=${apiKey}&id=${matchId}`);
                    const data = await response.json();
                    
                    if (data.status !== "success") {
                        throw new Error(data.message || "Failed to fetch match details");
                    }
                    
                    return data;
                } catch (error) {
                    throw new Error(`Error fetching match ${matchId}: ${error.message}`);
                }
            }
            
            // Function to fetch team-owner mapping
            async function fetchTeamOwnerMapping() {
                try {
                    const response = await fetch('teams.csv');
                    const text = await response.text();
                    
                    // Parse CSV
                    const lines = text.split('\n');
                    const headers = lines[0].split(',');
                    const mapping = {};
                    
                    for (let i = 1; i < lines.length; i++) {
                        const values = lines[i].split(',');
                        if (values.length >= headers.length) {
                            const playerId = values[4];
                            mapping[playerId] = {
                                owner: values[7],
                                player_name: values[6],
                                team_id: values[5]
                            };
                        }
                    }
                    
                    return mapping;
                } catch (error) {
                    throw new Error(`Error loading team-owner mapping: ${error.message}`);
                }
            }
            
            // Main function to process matches
            async function processMatches() {
                try {
                    statusMessage.textContent = 'Loading team-owner mapping...';
                    const teamOwnerMapping = await fetchTeamOwnerMapping();
                    
                    statusMessage.textContent = 'Fetching matches...';
                    const matches = await fetchSeriesMatches();
                    
                    const matchStats = {};
                    for (const match of matches) {
                        statusMessage.textContent = `Processing match: ${match.name}...`;
                        const details = await fetchMatchDetails(match.id);
                        // Process match details and update stats
                        processMatchDetails(details, match.id, teamOwnerMapping, matchStats);
                    }
                    
                    // Calculate final scores and display results
                    const ownerStats = calculateOwnerStats(matchStats, teamOwnerMapping);
                    displayResults(ownerStats);
                    
                    statusMessage.className = 'status-message success';
                    statusMessage.textContent = 'Data loaded successfully!';
                    dataContainer.classList.remove('hidden');
                    
                } catch (error) {
                    statusMessage.className = 'status-message error';
                    statusMessage.textContent = error.message;
                }
            }
            
            // Start processing
            processMatches();
            
            // Helper functions for processing and displaying data
            function processMatchDetails(matchData, matchId, teamOwnerMapping, matchStats) {
                const data = matchData.data || matchData;
                let ballByBall = data.ballByBall || data.bbb || [];
                
                if (!ballByBall || !ballByBall.length) {
                    return;
                }
                
                // Initialize match stats if needed
                if (!matchStats[matchId]) {
                    matchStats[matchId] = {};
                }
                
                // Process each ball
                ballByBall.forEach(inning => {
                    if (inning.overs) {
                        // Process each over
                        inning.overs.forEach(over => {
                            // Process each ball
                            over.balls.forEach(ball => {
                                processBall(ball, matchId, matchStats[matchId]);
                            });
                        });
                    } else {
                        // If it's a flat list of balls
                        processBall(inning, matchId, matchStats[matchId]);
                    }
                });
            }
            
            function processBall(ball, matchId, matchStats) {
                const batter = ball.batter || ball.batsman || {};
                const bowler = ball.bowler || {};
                
                const batterId = batter.id;
                const bowlerId = bowler.id;
                
                if (!batterId || !bowlerId) return;
                
                // Initialize player stats if needed
                [batterId, bowlerId].forEach(playerId => {
                    if (!matchStats[playerId]) {
                        matchStats[playerId] = {
                            name: playerId === batterId ? batter.name : bowler.name,
                            runs: 0,
                            balls: 0,
                            bowled_balls: 0,
                            runs_conceded: 0,
                            wickets: 0,
                            wicket_bowled_or_lbw: 0,
                            catches: 0,
                            run_outs: 0,
                            match_id: matchId
                        };
                    }
                });
                
                // Update batter stats
                const batterStats = matchStats[batterId];
                const runs = (ball.runs?.batter || ball.runs || 0);
                batterStats.runs += runs;
                batterStats.balls += 1;
                
                // Update bowler stats
                const bowlerStats = matchStats[bowlerId];
                bowlerStats.bowled_balls += 1;
                bowlerStats.runs_conceded += (ball.runs?.total || ball.runs || 0);
                
                // Handle wickets
                if (ball.isWicket || ball.wicket) {
                    const wicket = ball.wicket || {};
                    const wicketType = wicket.type;
                    
                    if (['bowled', 'caught', 'lbw', 'stumped', 'caught and bowled', 'hit wicket'].includes(wicketType)) {
                        bowlerStats.wickets += 1;
                        
                        if (['bowled', 'lbw', 'caught and bowled'].includes(wicketType)) {
                            bowlerStats.wicket_bowled_or_lbw += 1;
                        }
                    }
                    
                    // Handle catches
                    if (wicketType === 'caught') {
                        const fielder = (wicket.fielders || [])[0] || {};
                        const fielderId = fielder.id;
                        
                        if (fielderId) {
                            if (!matchStats[fielderId]) {
                                matchStats[fielderId] = {
                                    name: fielder.name,
                                    runs: 0,
                                    balls: 0,
                                    bowled_balls: 0,
                                    runs_conceded: 0,
                                    wickets: 0,
                                    wicket_bowled_or_lbw: 0,
                                    catches: 0,
                                    run_outs: 0,
                                    match_id: matchId
                                };
                            }
                            matchStats[fielderId].catches += 1;
                        }
                    }
                    
                    // Handle run outs
                    if (wicketType === 'run out') {
                        (wicket.fielders || []).forEach(fielder => {
                            const fielderId = fielder.id;
                            if (fielderId) {
                                if (!matchStats[fielderId]) {
                                    matchStats[fielderId] = {
                                        name: fielder.name,
                                        runs: 0,
                                        balls: 0,
                                        bowled_balls: 0,
                                        runs_conceded: 0,
                                        wickets: 0,
                                        wicket_bowled_or_lbw: 0,
                                        catches: 0,
                                        run_outs: 0,
                                        match_id: matchId
                                    };
                                }
                                matchStats[fielderId].run_outs += 1;
                            }
                        });
                    }
                }
            }
            
            function calculateOwnerStats(matchStats, teamOwnerMapping) {
                const ownerStats = {};
                
                // Process each match
                Object.entries(matchStats).forEach(([matchId, match]) => {
                    // Calculate scores for each player in the match
                    Object.entries(match).forEach(([playerId, stats]) => {
                        const score = calculatePlayerScore(stats);
                        stats.score = score;
                        
                        // Find owner info
                        const ownerInfo = teamOwnerMapping[playerId];
                        if (ownerInfo) {
                            const { owner, player_name, team_id } = ownerInfo;
                            
                            // Initialize owner entry if needed
                            if (!ownerStats[owner]) {
                                ownerStats[owner] = {
                                    totalScore: 0,
                                    players: []
                                };
                            }
                            
                            // Add player stats to owner's list
                            ownerStats[owner].players.push({
                                name: player_name,
                                teamId: team_id,
                                ...stats
                            });
                        }
                    });
                    
                    // Find highest scorer in each match and apply 1.3x multiplier
                    let maxScore = 0;
                    let highestScorer = null;
                    
                    Object.entries(match).forEach(([playerId, stats]) => {
                        if (stats.score > maxScore) {
                            maxScore = stats.score;
                            highestScorer = playerId;
                        }
                    });
                    
                    if (highestScorer) {
                        const stats = match[highestScorer];
                        stats.originalScore = stats.score;
                        stats.score *= 1.3;
                        stats.isHighestScorer = true;
                    }
                });
                
                // Calculate total scores for each owner
                Object.values(ownerStats).forEach(owner => {
                    owner.totalScore = owner.players.reduce((sum, player) => sum + player.score, 0);
                });
                
                return ownerStats;
            }
            
            function calculatePlayerScore(stats) {
                // Base score
                let score = 4;
                
                // Batting score
                if (stats.runs > 0) {
                    score += stats.runs;
                    if (stats.runs >= 50) score += 8;
                    if (stats.runs >= 100) score += 8;
                }
                
                // Bowling score
                const wickets = stats.wickets;
                const goodWickets = stats.wicket_bowled_or_lbw;
                score += (goodWickets * 20) + ((wickets - goodWickets) * 16);
                if (wickets >= 3) score += 15;
                
                // Fielding score
                score += (stats.catches * 8) + (stats.run_outs * 8);
                
                return score;
            }
            
            function displayResults(ownerStats) {
                const teamScoresBody = document.getElementById('team-scores-body');
                const playerScoresBody = document.getElementById('player-scores-body');
                
                // Clear existing content
                teamScoresBody.innerHTML = '';
                playerScoresBody.innerHTML = '';
                
                // Display team scores
                Object.entries(ownerStats)
                    .sort((a, b) => b[1].totalScore - a[1].totalScore)
                    .forEach(([owner, stats]) => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${owner}</td>
                            <td>${stats.totalScore.toFixed(2)}</td>
                            <td>${stats.players.length}</td>
                        `;
                        teamScoresBody.appendChild(row);
                    });
                
                // Display player scores
                const allPlayers = [];
                Object.entries(ownerStats).forEach(([owner, stats]) => {
                    stats.players.forEach(player => {
                        allPlayers.push({...player, owner});
                    });
                });
                
                allPlayers
                    .sort((a, b) => b.score - a.score)
                    .forEach(player => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${player.name}${player.isHighestScorer ? ' ‚≠ê (1.3x)' : ''}</td>
                            <td>${player.teamId}</td>
                            <td>${player.owner}</td>
                            <td>${player.runs || 0}</td>
                            <td>${player.wickets || 0}</td>
                            <td>${player.catches || 0}</td>
                            <td>${player.runOuts || 0}</td>
                            <td>${player.score.toFixed(2)}</td>
                            <td>${player.matchId}</td>
                        `;
                        playerScoresBody.appendChild(row);
                    });
            }
            
            async function fetchData() {
                const apiKey = document.getElementById('apiKey').value;
                if (!apiKey) {
                    alert('Please enter your API key');
                    return;
                }
                
                document.getElementById('loadingMessage').style.display = 'block';
                document.getElementById('results').style.display = 'none';
                
                try {
                    // Fetch team owner mapping
                    const teamOwnerMapping = await fetchTeamOwnerMapping();
                    
                    // Fetch series matches
                    const seriesId = '47b54677-34de-4378-9019-154e82b9cc1a'; // IPL 2024
                    const matches = await fetchSeriesMatches(apiKey, seriesId);
                    
                    // Process each match
                    const matchStats = {};
                    for (const match of matches) {
                        const matchDetails = await fetchMatchDetails(apiKey, match.id);
                        processMatchDetails(matchDetails, match.id, teamOwnerMapping, matchStats);
                    }
                    
                    // Calculate owner stats
                    const ownerStats = calculateOwnerStats(matchStats, teamOwnerMapping);
                    
                    // Display results
                    displayResults(ownerStats);
                    
                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('results').style.display = 'block';
                } catch (error) {
                    console.error('Error:', error);
                    document.getElementById('loadingMessage').textContent = 'Error: ' + error.message;
                }
            }
            
            async function fetchTeamOwnerMapping() {
                const response = await fetch('teams.csv');
                const text = await response.text();
                const lines = text.split('\n');
                const mapping = {};
                
                // Skip header row
                for (let i = 1; i < lines.length; i++) {
                    const [player_id, player_name, team_id, owner] = lines[i].split(',').map(s => s.trim());
                    if (player_id && owner) {
                        mapping[player_id] = { player_name, team_id, owner };
                    }
                }
                
                return mapping;
            }
            
            async function fetchSeriesMatches(apiKey, seriesId) {
                const response = await fetch(`https://api.cricapi.com/v1/series_info?apikey=${apiKey}&id=${seriesId}`);
                const data = await response.json();
                
                if (data.status !== 'success') {
                    throw new Error(data.message || 'Failed to fetch series matches');
                }
                
                return data.data.matchList || [];
            }
            
            async function fetchMatchDetails(apiKey, matchId) {
                const response = await fetch(`https://api.cricapi.com/v1/match_info?apikey=${apiKey}&id=${matchId}`);
                const data = await response.json();
                
                if (data.status !== 'success') {
                    throw new Error(data.message || 'Failed to fetch match details');
                }
                
                return data;
            }
            
            function displayResults(ownerStats) {
                const resultsDiv = document.getElementById('results');
                resultsDiv.innerHTML = '';
                
                // Create owner scores table
                const ownerTable = document.createElement('table');
                ownerTable.className = 'table table-striped';
                ownerTable.innerHTML = `
                    <thead>
                        <tr>
                            <th>Owner</th>
                            <th>Total Score</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${Object.entries(ownerStats)
                            .sort((a, b) => b[1].totalScore - a[1].totalScore)
                            .map(([owner, stats]) => `
                                <tr>
                                    <td>${owner}</td>
                                    <td>${stats.totalScore.toFixed(1)}</td>
                                </tr>
                            `).join('')}
                    </tbody>
                `;
                
                // Create player scores table
                const playerTable = document.createElement('table');
                playerTable.className = 'table table-striped mt-4';
                playerTable.innerHTML = `
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Owner</th>
                            <th>Runs</th>
                            <th>Wickets</th>
                            <th>Catches</th>
                            <th>Run Outs</th>
                            <th>Score</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${Object.entries(ownerStats)
                            .flatMap(([owner, stats]) => 
                                stats.players.map(player => `
                                    <tr>
                                        <td>${player.name}</td>
                                        <td>${owner}</td>
                                        <td>${player.runs}</td>
                                        <td>${player.wickets}</td>
                                        <td>${player.catches}</td>
                                        <td>${player.run_outs}</td>
                                        <td>${player.score.toFixed(1)}${player.isHighestScorer ? ' *' : ''}</td>
                                    </tr>
                                `)
                            ).join('')}
                    </tbody>
                `;
                
                resultsDiv.appendChild(ownerTable);
                resultsDiv.appendChild(playerTable);
            }
        });
    </script>
</body>
</html> 