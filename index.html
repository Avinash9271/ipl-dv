<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cricket Player Dashboard</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #0056b3;
            text-align: center;
        }
        #loading {
            text-align: center;
            font-size: 18px;
            margin: 30px 0;
            color: #666;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #0056b3;
            color: white;
            position: sticky;
            top: 0;
        }
        tr:hover {
            background-color: #f1f8ff;
        }
        .error {
            color: red;
            text-align: center;
            padding: 20px;
            background-color: #ffeeee;
            border-radius: 5px;
            margin: 20px 0;
        }
        .refresh-btn {
            background-color: #0056b3;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: block;
            margin: 20px auto;
        }
        .refresh-btn:hover {
            background-color: #003d7a;
        }
        .stats-info {
            text-align: center;
            margin-bottom: 20px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Cricket Player Dashboard</h1>
        <div class="stats-info">Last updated: <span id="update-time"></span></div>
        <div id="loading">Loading player data...</div>
        <div id="error-container"></div>
        <div id="player-table-container"></div>
        <button class="refresh-btn" onclick="refreshData()">Refresh Data</button>
    </div>

    <script>
        // Constants
        const API_KEY = "282bffef-9065-43b3-91f0-df54dec227fd";
        const IPL_2025_SERIES_ID = "d5a498c8-7596-4b93-8ab0-e0efc3345312";
        
        // Variables to store data
        let teamOwnerMapping = {};
        let playerStats = {};
        let matchesProcessed = 0;
        let playerNameToId = {}; // Track players by name to prevent duplicates
        let matchHighestScorers = {}; // Track highest scorer for each match
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            fetchData();
            // Auto-refresh every 5 minutes
            setInterval(fetchData, 5 * 60 * 1000);
        });
        
        // Function to refresh data manually
        function refreshData() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('player-table-container').innerHTML = '';
            document.getElementById('error-container').innerHTML = '';
            fetchData();
        }
        
        // Add timestamp to prevent caching
        function addTimestamp(url) {
            return `${url}${url.includes('?') ? '&' : '?'}_t=${Date.now()}`;
        }
        
        // Main function to fetch all required data
        async function fetchData() {
            try {
                // Reset data
                playerStats = {};
                matchesProcessed = 0;
                
                // Step 1: Load team owner mapping from CSV
                await fetchTeamOwnerMapping();
                console.log("Team owner mapping loaded:", Object.keys(teamOwnerMapping).length, "players");
                
                // Initialize player stats with base values from team mapping
                initializePlayerStats();
                
                // Step 2: Fetch all matches for the series
                const matches = await fetchSeriesMatches(API_KEY, IPL_2025_SERIES_ID);
                console.log("Fetched matches:", matches.length);
                
                // Step 3: Process each match to calculate player stats
                if (matches && matches.length > 0) {
                    const startedMatches = matches.filter(match => match.matchStarted);
                    console.log(`Found ${startedMatches.length} started matches`);
                    
                    for (const match of startedMatches) {
                        document.getElementById('loading').textContent = `Loading match details for ${match.name}...`;
                        try {
                            const matchDetails = await fetchMatchDetails(API_KEY, match.id);
                            if (matchDetails && matchDetails.status === "success") {
                                processMatchData(matchDetails);
                                matchesProcessed++;
                            }
                        } catch (matchError) {
                            console.error(`Error processing match ${match.id}:`, matchError);
                        }
                    }
                }
                
                // Step 4: Calculate and display player scores
                calculatePlayerScores();
                displayPlayerTable();
                
                // Update the timestamp
                const now = new Date();
                document.getElementById('update-time').textContent = now.toLocaleString();
                document.getElementById('loading').style.display = 'none';
                
            } catch (error) {
                console.error("Error fetching data:", error);
                document.getElementById('error-container').innerHTML = `
                    <div class="error">
                        <h3>Error loading data</h3>
                        <p>${error.message}</p>
                    </div>
                `;
                document.getElementById('loading').style.display = 'none';
            }
        }
        
        // Function to fetch team-owner mapping from CSV
        async function fetchTeamOwnerMapping() {
            try {
                console.log("Fetching team owner mapping");
                // First try to fetch from GitHub Pages
                const response = await fetch(`teams.csv?t=${Date.now()}`, {
                    cache: 'no-store'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch teams.csv: ${response.status}`);
                }
                
                const csvText = await response.text();
                console.log("CSV text length:", csvText.length);
                teamOwnerMapping = parseTeamOwnerMapping(csvText);
                
            } catch (error) {
                console.error("Error fetching team-owner mapping:", error);
                throw error;
            }
        }
        
        // Function to parse CSV text into team-owner mapping
        function parseTeamOwnerMapping(csvText) {
            console.log("Parsing team owner mapping");
            const mapping = {};
            
            // Split the CSV text into lines
            const lines = csvText.trim().split('\n');
            console.log("CSV lines:", lines.length);
            
            // Process each line
            for (let i = 1; i < lines.length; i++) { // Skip header row
                const line = lines[i].trim();
                if (!line) continue; // Skip empty lines
                
                const values = line.split(',');
                if (values.length >= 8) {
                    // Extract values from CSV columns
                    const player_id = String(values[4]).trim();
                    const team_id = String(values[5]).trim();
                    const player_name = values[6].trim();
                    const owner = values[7].trim();
                    
                    // Store in mapping
                    mapping[player_id] = {
                        team_id: team_id,
                        player_name: player_name,
                        owner: owner
                    };
                    
                    console.log(`Added player: ${player_id} - ${player_name} (${owner})`);
                }
            }
            
            console.log("Mapping created with", Object.keys(mapping).length, "players");
            return mapping;
        }
        
        // Function to initialize player stats with base values
        function initializePlayerStats() {
            for (const playerId in teamOwnerMapping) {
                const playerInfo = teamOwnerMapping[playerId];
                playerStats[playerId] = {
                    player_id: playerId,
                    player_name: playerInfo.player_name,
                    team_id: playerInfo.team_id,
                    owner: playerInfo.owner,
                    runs: 0,
                    balls_faced: 0,
                    wickets: 0,
                    balls_bowled: 0,
                    catches: 0,
                    run_outs: 0,
                    economy: 0,
                    high_score: 0,
                    strike_rate: 0,
                    runs_conceded: 0,
                    dot_balls: 0,
                    good_ones: 0,
                    score: 0,
                    matchScores: {} // Track scores per match
                };
            }
            console.log("Initialized player stats for", Object.keys(playerStats).length, "players");
        }
        
        // Function to fetch series matches
        async function fetchSeriesMatches(apiKey, seriesId) {
            try {
                console.log(`Fetching matches for series: ${seriesId}`);
                const url = addTimestamp(`https://api.cricapi.com/v1/series_info?apikey=${apiKey}&id=${seriesId}`);
                
                const response = await fetch(url, {
                    method: 'GET',
                    cache: 'no-store'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch series matches: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Series API Response:', data);
                
                if (data.status !== "success") {
                    throw new Error(data.info || data.error || 'API returned unsuccessful status');
                }
                
                return data.data.matchList || [];
                
            } catch (error) {
                console.error("Error fetching series matches:", error);
                return [];
            }
        }
        
        // Function to fetch match details
        async function fetchMatchDetails(apiKey, matchId) {
            try {
                console.log(`Fetching details for match: ${matchId}`);
                const url = addTimestamp(`https://api.cricapi.com/v1/match_bbb?apikey=${apiKey}&id=${matchId}`);
                
                const response = await fetch(url, {
                    method: 'GET',
                    cache: 'no-store'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch match details: ${response.status}`);
                }
                
                const data = await response.json();
                console.log(`Match details API Response for ${matchId}:`, data.status);
                return data;
                
            } catch (error) {
                console.error(`Error fetching match ${matchId} details:`, error);
                return null;
            }
        }
        
        // Function to process match data and update player stats
        function processMatchData(matchData) {
            console.log("Processing match data");
            
            if (!matchData || !matchData.data || !matchData.data.bbb) {
                console.warn("No ball-by-ball data found in match");
                return;
            }
            
            const balls = matchData.data.bbb;
            const matchId = matchData.data.id;
            console.log(`Processing ${balls.length} balls for match: ${matchId}`);
            
            // Reset player scores for this match
            const matchPlayerScores = {};
            
            // Process each ball
            balls.forEach(ball => {
                processBall(ball, matchId, matchPlayerScores);
            });
            
            // Store match scores for each player
            for (const playerId in matchPlayerScores) {
                if (playerStats[playerId]) {
                    playerStats[playerId].matchScores = playerStats[playerId].matchScores || {};
                    playerStats[playerId].matchScores[matchId] = matchPlayerScores[playerId];
                }
            }
            
            // Find player with highest score for this match
            let highestScore = -Infinity;
            let highestScorerId = null;
            
            for (const playerId in matchPlayerScores) {
                const score = matchPlayerScores[playerId];
                if (score > highestScore) {
                    highestScore = score;
                    highestScorerId = playerId;
                }
            }
            
            if (highestScorerId) {
                matchHighestScorers[matchId] = {
                    playerId: highestScorerId,
                    score: highestScore,
                    playerName: playerStats[highestScorerId]?.player_name || "Unknown Player"
                };
                console.log(`Highest scorer for match ${matchId}: ${matchHighestScorers[matchId].playerName} with ${highestScore} points`);
            }
        }
        
        // Function to process a single ball
        function processBall(ball, matchId, matchPlayerScores) {
            if (!ball || !ball.batsman || !ball.bowler) return;
            
            const batterId = String(ball.batsman.id || "");
            const batterName = ball.batsman.name || "";
            const bowlerId = String(ball.bowler.id || "");
            const bowlerName = ball.bowler.name || "";
            
            // Handle batsman stats
            updatePlayerStats(batterId, batterName, ball, true, matchId, matchPlayerScores);
            
            // Handle bowler stats
            updatePlayerStats(bowlerId, bowlerName, ball, false, matchId, matchPlayerScores);
            
            // Process fielding stats (catches, run outs)
            if (ball.dismissal === "catch" && ball.catcher) {
                const catcherId = getCatcherId(ball);
                const catcherName = typeof ball.catcher === 'object' ? ball.catcher.name : ball.catcher;
                if (catcherId) {
                    // Get or create the player
                    const playerId = getOrCreatePlayer(catcherId, catcherName);
                    if (playerId && playerStats[playerId]) {
                        playerStats[playerId].catches += 1;
                        
                        // Update player's score for this match
                        matchPlayerScores[playerId] = (matchPlayerScores[playerId] || 0) + 10; // 10 points for a catch
                    }
                }
            } else if (ball.dismissal && ball.dismissal.toLowerCase() === "run out") {
                // Try to find the run out fielder if available
                if (ball.fielder) {
                    const fielderId = typeof ball.fielder === 'object' ? String(ball.fielder.id || "") : "";
                    const fielderName = typeof ball.fielder === 'object' ? ball.fielder.name : ball.fielder;
                    
                    if (fielderId) {
                        const playerId = getOrCreatePlayer(fielderId, fielderName);
                        if (playerId && playerStats[playerId]) {
                            playerStats[playerId].run_outs += 1;
                            
                            // Update player's score for this match
                            matchPlayerScores[playerId] = (matchPlayerScores[playerId] || 0) + 10; // 10 points for a run out
                        }
                    }
                }
            }
        }
        
        // Function to update player stats
        function updatePlayerStats(playerId, playerName, ball, isBatsman, matchId, matchPlayerScores) {
            if (!playerId || !playerName) return;
            
            // Get or create proper player ID to prevent duplicates
            const canonicalId = getOrCreatePlayer(playerId, playerName);
            
            if (!canonicalId || !playerStats[canonicalId]) return;
            
            // Initialize match score for this player if it doesn't exist
            matchPlayerScores[canonicalId] = matchPlayerScores[canonicalId] || 0;
            
            if (isBatsman) {
                // Update batting stats
                const runs = parseInt(ball.runs || 0);
                playerStats[canonicalId].runs += runs;
                
                // Only count as ball faced if it's not a wide or no ball
                const isWide = ball.isWide || ball.type === "wide";
                const isNoBall = ball.isNoBall || ball.type === "noball";
                
                if (!isWide && !isNoBall) {
                    playerStats[canonicalId].balls_faced += 1;
                }
                
                // Update high score
                if (runs > playerStats[canonicalId].high_score) {
                    playerStats[canonicalId].high_score = runs;
                }
                
                // Update strike rate
                if (playerStats[canonicalId].balls_faced > 0) {
                    playerStats[canonicalId].strike_rate = 
                        (playerStats[canonicalId].runs / playerStats[canonicalId].balls_faced) * 100;
                }
                
                // Update player's score for this match
                matchPlayerScores[canonicalId] += runs;
            } else {
                // Update bowling stats
                playerStats[canonicalId].balls_bowled += 1;
                const runsConceded = parseInt(ball.runs || 0);
                playerStats[canonicalId].runs_conceded += runsConceded;
                
                // Check for dot ball
                if (parseInt(ball.runs || 0) === 0) {
                    playerStats[canonicalId].dot_balls += 1;
                    matchPlayerScores[canonicalId] += 1; // 1 point for a dot ball
                }
                
                // Check for wicket
                if (ball.dismissal) {
                    const dismissalType = ball.dismissal.toLowerCase();
                    if (["bowled", "caught", "lbw", "stumped", "caught and bowled", "hit wicket"].includes(dismissalType)) {
                        playerStats[canonicalId].wickets += 1;
                        matchPlayerScores[canonicalId] += 20; // 20 points for a wicket
                        
                        // Check for good_one (bowled/lbw/caught and bowled)
                        if (["bowled", "lbw", "caught and bowled"].includes(dismissalType)) {
                            playerStats[canonicalId].good_ones += 1;
                            matchPlayerScores[canonicalId] += 10; // 10 points for a good_one
                        }
                    }
                }
                
                // Calculate economy
                if (playerStats[canonicalId].balls_bowled >= 6) {
                    const overs = Math.floor(playerStats[canonicalId].balls_bowled / 6) + 
                        (playerStats[canonicalId].balls_bowled % 6) / 10;
                    playerStats[canonicalId].economy = 
                        playerStats[canonicalId].runs_conceded / overs;
                }
                
                // Update bowling points for this match
                // The formula here should roughly match what we'll calculate in the final score
                matchPlayerScores[canonicalId] += 3 * (1.5 - runsConceded); // Economy bonus/penalty
            }
        }
        
        // Function to get existing player or create a new one, preventing duplicates
        function getOrCreatePlayer(playerId, playerName) {
            if (!playerName) return playerId;
            
            // Normalize player name for case-insensitive matching
            const normalizedName = playerName.trim().toLowerCase();
            
            // Check if we've seen this player name before
            if (playerNameToId[normalizedName]) {
                // We have this player already with a different ID
                const existingId = playerNameToId[normalizedName];
                
                if (existingId !== playerId) {
                    console.log(`Found duplicate player! ${playerName} has IDs: ${existingId} and ${playerId}`);
                    
                    // If we have stats for this new ID, merge them into the existing player
                    if (playerStats[playerId]) {
                        mergePlayerStats(existingId, playerId);
                        // Delete the duplicate entry
                        delete playerStats[playerId];
                    }
                }
                
                // Return the canonical ID for this player
                return existingId;
            }
            
            // Check for common name variations (e.g., "V Kohli" vs "Virat Kohli")
            // This helps match players across different formats in the API
            const matchedId = findPlayerByNameVariation(normalizedName);
            if (matchedId) {
                playerNameToId[normalizedName] = matchedId;
                return matchedId;
            }
            
            // Check for existing player in team mapping by ID
            if (teamOwnerMapping[playerId]) {
                playerNameToId[normalizedName] = playerId;
                return playerId;
            }
            
            // Check if player exists in team mapping by name
            let foundId = null;
            for (const [id, info] of Object.entries(teamOwnerMapping)) {
                if (info.player_name.toLowerCase() === normalizedName) {
                    foundId = id;
                    break;
                }
            }
            
            if (foundId) {
                playerNameToId[normalizedName] = foundId;
                
                // If we have stats for the API ID, merge them into the CSV ID
                if (playerStats[playerId] && playerId !== foundId) {
                    mergePlayerStats(foundId, playerId);
                    // Delete the duplicate entry
                    delete playerStats[playerId];
                }
                
                return foundId;
            }
            
            // This is a new player not in our CSV
            // Create player record if it doesn't exist
            if (!playerStats[playerId]) {
                const ownerInfo = findOwnerByName(playerName);
                playerStats[playerId] = {
                    player_id: playerId,
                    player_name: playerName,
                    team_id: ownerInfo.team_id || "",
                    owner: ownerInfo.owner || "Unknown",
                    runs: 0,
                    balls_faced: 0,
                    wickets: 0,
                    balls_bowled: 0,
                    catches: 0,
                    run_outs: 0,
                    economy: 0,
                    high_score: 0,
                    strike_rate: 0,
                    runs_conceded: 0,
                    dot_balls: 0,
                    good_ones: 0,
                    score: 0,
                    matchScores: {} // Track scores per match
                };
                console.log(`Added new player: ${playerName} (${playerId})`);
            }
            
            // Register this player
            playerNameToId[normalizedName] = playerId;
            return playerId;
        }
        
        // Helper function to find players by name variations
        function findPlayerByNameVariation(normalizedName) {
            // Common abbreviations and variations
            // For example, "V Kohli" should match "Virat Kohli"
            for (const [id, info] of Object.entries(teamOwnerMapping)) {
                const fullName = info.player_name.toLowerCase();
                
                // Case 1: Full name in mapping matches part of the name from API
                if (normalizedName.includes(fullName)) {
                    return id;
                }
                
                // Case 2: First initial + last name (e.g. "V Kohli" for "Virat Kohli")
                const nameParts = fullName.split(' ');
                if (nameParts.length >= 2) {
                    const lastName = nameParts[nameParts.length - 1];
                    const firstInitial = nameParts[0][0];
                    
                    // Check if the name matches pattern "F Lastname" (e.g. "V Kohli")
                    const initialLastNamePattern = `${firstInitial} ${lastName}`;
                    if (normalizedName === initialLastNamePattern) {
                        return id;
                    }
                    
                    // Check if last name matches and it's a unique last name
                    if (normalizedName.includes(lastName) && lastName.length > 3) {
                        // Check if this last name is unique enough
                        let lastNameCount = 0;
                        for (const otherInfo of Object.values(teamOwnerMapping)) {
                            if (otherInfo.player_name.toLowerCase().includes(lastName)) {
                                lastNameCount++;
                            }
                        }
                        
                        // If this last name is unique in our mapping, use it
                        if (lastNameCount === 1) {
                            return id;
                        }
                    }
                }
            }
            
            return null;
        }
        
        // Function to merge stats from sourceId into targetId
        function mergePlayerStats(targetId, sourceId) {
            if (!playerStats[targetId] || !playerStats[sourceId]) return;
            
            console.log(`Merging player stats from ${sourceId} to ${targetId}`);
            
            const target = playerStats[targetId];
            const source = playerStats[sourceId];
            
            // Merge numerical stats
            target.runs += source.runs;
            target.balls_faced += source.balls_faced;
            target.wickets += source.wickets;
            target.balls_bowled += source.balls_bowled;
            target.catches += source.catches;
            target.run_outs += source.run_outs;
            target.runs_conceded += source.runs_conceded;
            target.dot_balls += source.dot_balls;
            target.good_ones += source.good_ones;
            
            // Update high score if needed
            if (source.high_score > target.high_score) {
                target.high_score = source.high_score;
            }
            
            // Recalculate strike rate
            if (target.balls_faced > 0) {
                target.strike_rate = (target.runs / target.balls_faced) * 100;
            }
            
            // Recalculate economy
            if (target.balls_bowled >= 6) {
                const overs = Math.floor(target.balls_bowled / 6) + (target.balls_bowled % 6) / 10;
                target.economy = target.runs_conceded / overs;
            }
            
            console.log(`Merged stats for ${target.player_name}`);
        }
        
        // Helper to extract catcher ID - schema might vary
        function getCatcherId(ball) {
            if (ball.catcher && typeof ball.catcher === 'object' && ball.catcher.id) {
                return String(ball.catcher.id);
            } else if (ball.catcher && typeof ball.catcher === 'string') {
                // Look up player by name
                const catcherName = ball.catcher.toLowerCase();
                for (const [playerName, playerId] of Object.entries(playerNameToId)) {
                    if (playerName === catcherName) {
                        return playerId;
                    }
                }
            }
            return null;
        }
        
        // Helper function to find owner info by player name
        function findOwnerByName(playerName) {
            if (!playerName) return { owner: "Unknown", team_id: "" };
            
            // Look for exact name matches first
            for (const [playerId, info] of Object.entries(teamOwnerMapping)) {
                if (info.player_name.toLowerCase() === playerName.toLowerCase()) {
                    console.log(`Found exact owner match for: ${playerName} -> ${info.owner}`);
                    return { owner: info.owner, team_id: info.team_id };
                }
            }
            
            // No special cases - just return Unknown if no match found
            return { owner: "Unknown", team_id: "" };
        }
        
        // Calculate player scores using the provided score function
        function calculatePlayerScores() {
            for (const playerId in playerStats) {
                const player = playerStats[playerId];
                
                // Score calculation based on the provided formula
                let score = 0;
                
                // Batting score
                let batsman_score = 0;
                if (player.balls_faced > 0) {
                    const sr = player.runs / player.balls_faced;
                    batsman_score = player.runs + (sr - 1.5) * Math.max(player.runs, player.balls_faced) + 
                                   (player.runs >= 50 ? 8 : 0) + (player.runs >= 100 ? 8 : 0);
                }
                
                // Bowling score
                let bowlers_score = 0;
                if (player.balls_bowled > 0) {
                    bowlers_score = 3 * (1.5 * player.balls_bowled - player.runs_conceded) + 
                                   player.wickets * 20 + player.good_ones * 10 + 
                                   (player.wickets >= 3 ? 15 : 0) + player.dot_balls;
                }
                
                // Fielding score
                const fielding_score = (player.catches + player.run_outs) * 10;
                
                // Base score without multipliers
                const baseScore = batsman_score + bowlers_score + fielding_score + 4;
                
                // Apply 1.3x multiplier ONLY to the match scores where this player was highest scorer
                // First, calculate the sum of all match scores WITHOUT any multiplier
                let totalMatchScores = 0;
                let multipliedMatchScores = 0;
                
                // Track which matches got multiplier for display
                const multipliedMatches = [];
                
                // Process each match score
                for (const matchId in player.matchScores) {
                    const matchScore = player.matchScores[matchId];
                    
                    // Check if this player was the highest scorer in this match
                    if (matchHighestScorers[matchId] && matchHighestScorers[matchId].playerId === playerId) {
                        // Apply 1.3x multiplier ONLY to this match's score
                        multipliedMatchScores += matchScore * 1.3;
                        multipliedMatches.push(matchId);
                        console.log(`Applied 1.3x multiplier to ${player.player_name}'s score of ${matchScore} in match ${matchId}`);
                    } else {
                        // No multiplier for this match
                        multipliedMatchScores += matchScore;
                    }
                    
                    // Add to total without multiplier (for tracking)
                    totalMatchScores += matchScore;
                }
                
                // Final score is the correctly multiplied match scores
                score = multipliedMatchScores;
                
                // Store the calculated score
                player.score = Math.round(score);
                player.multipliedMatches = multipliedMatches; // Store which matches got multiplier
                
                // Log detailed score breakdown for debugging
                console.log(`${player.player_name} score: ${player.score} ` + 
                    `(Batting: ${Math.round(batsman_score)}, ` +
                    `Bowling: ${Math.round(bowlers_score)}, ` + 
                    `Fielding: ${fielding_score}, ` +
                    `Multiplier: ${multipliedMatches.length > 0 ? '1.3x on ' + multipliedMatches.length + ' matches' : 'None'})`);
            }
            
            console.log("Calculated scores for all players");
        }
        
        // Function to display player table
        function displayPlayerTable() {
            console.log("Displaying player table");
            const container = document.getElementById('player-table-container');
            
            // Get all players and sort by score (descending)
            const players = Object.values(playerStats).sort((a, b) => b.score - a.score);
            
            // Create table HTML
            let tableHtml = `
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Owner</th>
                            <th>Runs</th>
                            <th>SR</th>
                            <th>Wickets</th>
                            <th>Economy</th>
                            <th>Dots</th>
                            <th>Catches</th>
                            <th>Run Outs</th>
                            <th>Score</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Add player rows
            players.forEach((player, index) => {
                // Add a highlight for players who got the multiplier
                const rowClass = player.multipliedMatches && player.multipliedMatches.length > 0 ? 
                    'style="background-color: #ffffd0;"' : '';
                
                // Create a star icon with the number of matches that got multiplier
                const starIcon = player.multipliedMatches && player.multipliedMatches.length > 0 ? 
                    ` ðŸŒŸÃ—${player.multipliedMatches.length}` : '';
                
                tableHtml += `
                    <tr ${rowClass}>
                        <td>${index + 1}</td>
                        <td>${player.player_name}${starIcon}</td>
                        <td>${player.owner}</td>
                        <td>${player.runs}</td>
                        <td>${player.strike_rate.toFixed(2)}</td>
                        <td>${player.wickets}</td>
                        <td>${player.economy.toFixed(2)}</td>
                        <td>${player.dot_balls}</td>
                        <td>${player.catches}</td>
                        <td>${player.run_outs}</td>
                        <td><strong>${player.score}</strong></td>
                    </tr>
                `;
            });
            
            tableHtml += `
                    </tbody>
                </table>
                <div class="stats-info">
                    Matches processed: ${matchesProcessed} | Players: ${players.length}
                </div>
            `;
            
            // Update the container
            container.innerHTML = tableHtml;
        }
    </script>
</body>
</html> 