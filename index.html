<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cricket Stats</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .table {
            margin-top: 20px;
        }
        #loadingMessage {
            display: none;
            margin: 20px 0;
        }
        #results {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Cricket Stats</h1>
        
        <div class="row mt-4">
            <div class="col-md-6">
                <div class="input-group">
                    <input type="text" id="apiKey" class="form-control" placeholder="Enter your CricAPI key">
                    <button class="btn btn-primary" onclick="fetchData()">Fetch Data</button>
                </div>
            </div>
        </div>
        
        <div id="loadingMessage" class="alert alert-info">
            Loading data from CricAPI...
        </div>
        
        <div id="results"></div>
    </div>
    
    <script>
        // Series ID for IPL 2024
        const IPL_2024_SERIES_ID = "47b54677-34de-4378-9019-154e82b9cc1a";
        
        async function fetchData() {
            const apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                alert('Please enter your API key');
                return;
            }
            
            document.getElementById('loadingMessage').style.display = 'block';
            document.getElementById('results').style.display = 'none';
            
            try {
                // Fetch team owner mapping
                const teamOwnerMapping = await fetchTeamOwnerMapping();
                
                // Fetch series matches
                const matches = await fetchSeriesMatches(apiKey, IPL_2024_SERIES_ID);
                
                // Process each match
                const matchStats = {};
                for (const match of matches) {
                    const matchDetails = await fetchMatchDetails(apiKey, match.id);
                    processMatchDetails(matchDetails, match.id, teamOwnerMapping, matchStats);
                }
                
                // Calculate owner stats
                const ownerStats = calculateOwnerStats(matchStats, teamOwnerMapping);
                
                // Display results
                displayResults(ownerStats);
                
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('results').style.display = 'block';
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('loadingMessage').textContent = 'Error: ' + error.message;
            }
        }
        
        async function fetchTeamOwnerMapping() {
            const response = await fetch('teams.csv');
            const text = await response.text();
            const lines = text.split('\n');
            const mapping = {};
            
            // Skip header row
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(s => s.trim());
                if (values.length >= 4) {
                    const [player_id, player_name, team_id, owner] = values;
                    if (player_id && owner) {
                        mapping[player_id] = { player_name, team_id, owner };
                    }
                }
            }
            
            return mapping;
        }
        
        async function fetchSeriesMatches(apiKey, seriesId) {
            const response = await fetch(`https://api.cricapi.com/v1/series_info?apikey=${apiKey}&id=${seriesId}`);
            const data = await response.json();
            
            if (data.status !== 'success') {
                throw new Error(data.message || 'Failed to fetch series matches');
            }
            
            return data.data.matchList || [];
        }
        
        async function fetchMatchDetails(apiKey, matchId) {
            const response = await fetch(`https://api.cricapi.com/v1/match_bbb?apikey=${apiKey}&id=${matchId}`);
            const data = await response.json();
            
            if (data.status !== 'success') {
                throw new Error(data.message || 'Failed to fetch match details');
            }
            
            return data;
        }
        
        function processMatchDetails(matchData, matchId, teamOwnerMapping, matchStats) {
            const data = matchData.data || matchData;
            let ballByBall = data.ballByBall || data.bbb || [];
            
            if (!ballByBall || !ballByBall.length) {
                return;
            }
            
            // Initialize match stats if needed
            if (!matchStats[matchId]) {
                matchStats[matchId] = {};
            }
            
            // Process each ball
            ballByBall.forEach(inning => {
                if (inning.overs) {
                    // Process each over
                    inning.overs.forEach(over => {
                        // Process each ball
                        over.balls.forEach(ball => {
                            processBall(ball, matchId, matchStats[matchId]);
                        });
                    });
                } else {
                    // If it's a flat list of balls
                    processBall(inning, matchId, matchStats[matchId]);
                }
            });
        }
        
        function processBall(ball, matchId, matchStats) {
            const batter = ball.batter || ball.batsman || {};
            const bowler = ball.bowler || {};
            
            const batterId = batter.id;
            const bowlerId = bowler.id;
            
            if (!batterId || !bowlerId) return;
            
            // Initialize player stats if needed
            [batterId, bowlerId].forEach(playerId => {
                if (!matchStats[playerId]) {
                    matchStats[playerId] = {
                        name: playerId === batterId ? batter.name : bowler.name,
                        runs: 0,
                        balls: 0,
                        bowled_balls: 0,
                        runs_conceded: 0,
                        wickets: 0,
                        wicket_bowled_or_lbw: 0,
                        catches: 0,
                        run_outs: 0,
                        match_id: matchId
                    };
                }
            });
            
            // Update batter stats
            const batterStats = matchStats[batterId];
            const runs = (ball.runs?.batter || ball.runs || 0);
            batterStats.runs += runs;
            batterStats.balls += 1;
            
            // Update bowler stats
            const bowlerStats = matchStats[bowlerId];
            bowlerStats.bowled_balls += 1;
            bowlerStats.runs_conceded += (ball.runs?.total || ball.runs || 0);
            
            // Handle wickets
            if (ball.isWicket || ball.wicket) {
                const wicket = ball.wicket || {};
                const wicketType = wicket.type;
                
                if (['bowled', 'caught', 'lbw', 'stumped', 'caught and bowled', 'hit wicket'].includes(wicketType)) {
                    bowlerStats.wickets += 1;
                    
                    if (['bowled', 'lbw', 'caught and bowled'].includes(wicketType)) {
                        bowlerStats.wicket_bowled_or_lbw += 1;
                    }
                }
                
                // Handle catches
                if (wicketType === 'caught') {
                    const fielder = (wicket.fielders || [])[0] || {};
                    const fielderId = fielder.id;
                    
                    if (fielderId) {
                        if (!matchStats[fielderId]) {
                            matchStats[fielderId] = {
                                name: fielder.name,
                                runs: 0,
                                balls: 0,
                                bowled_balls: 0,
                                runs_conceded: 0,
                                wickets: 0,
                                wicket_bowled_or_lbw: 0,
                                catches: 0,
                                run_outs: 0,
                                match_id: matchId
                            };
                        }
                        matchStats[fielderId].catches += 1;
                    }
                }
                
                // Handle run outs
                if (wicketType === 'run out') {
                    (wicket.fielders || []).forEach(fielder => {
                        const fielderId = fielder.id;
                        if (fielderId) {
                            if (!matchStats[fielderId]) {
                                matchStats[fielderId] = {
                                    name: fielder.name,
                                    runs: 0,
                                    balls: 0,
                                    bowled_balls: 0,
                                    runs_conceded: 0,
                                    wickets: 0,
                                    wicket_bowled_or_lbw: 0,
                                    catches: 0,
                                    run_outs: 0,
                                    match_id: matchId
                                };
                            }
                            matchStats[fielderId].run_outs += 1;
                        }
                    });
                }
            }
        }
        
        function calculateOwnerStats(matchStats, teamOwnerMapping) {
            const ownerStats = {};
            
            // Process each match
            Object.entries(matchStats).forEach(([matchId, match]) => {
                // Calculate scores for each player in the match
                Object.entries(match).forEach(([playerId, stats]) => {
                    const score = calculatePlayerScore(stats);
                    stats.score = score;
                    
                    // Find owner info
                    const ownerInfo = teamOwnerMapping[playerId];
                    if (ownerInfo) {
                        const { owner, player_name, team_id } = ownerInfo;
                        
                        // Initialize owner entry if needed
                        if (!ownerStats[owner]) {
                            ownerStats[owner] = {
                                totalScore: 0,
                                players: []
                            };
                        }
                        
                        // Add player stats to owner's list
                        ownerStats[owner].players.push({
                            name: player_name,
                            teamId: team_id,
                            ...stats
                        });
                    }
                });
                
                // Find highest scorer in each match and apply 1.3x multiplier
                let maxScore = 0;
                let highestScorer = null;
                
                Object.entries(match).forEach(([playerId, stats]) => {
                    if (stats.score > maxScore) {
                        maxScore = stats.score;
                        highestScorer = playerId;
                    }
                });
                
                if (highestScorer) {
                    const stats = match[highestScorer];
                    stats.originalScore = stats.score;
                    stats.score *= 1.3;
                    stats.isHighestScorer = true;
                }
            });
            
            // Calculate total scores for each owner
            Object.values(ownerStats).forEach(owner => {
                owner.totalScore = owner.players.reduce((sum, player) => sum + player.score, 0);
            });
            
            return ownerStats;
        }
        
        function calculatePlayerScore(stats) {
            // Base score
            let score = 4;
            
            // Batting score
            if (stats.runs > 0) {
                score += stats.runs;
                if (stats.runs >= 50) score += 8;
                if (stats.runs >= 100) score += 8;
            }
            
            // Bowling score
            const wickets = stats.wickets;
            const goodWickets = stats.wicket_bowled_or_lbw;
            score += (goodWickets * 20) + ((wickets - goodWickets) * 16);
            if (wickets >= 3) score += 15;
            
            // Fielding score
            score += (stats.catches * 8) + (stats.run_outs * 8);
            
            return score;
        }
        
        function displayResults(ownerStats) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';
            
            // Create owner scores table
            const ownerTable = document.createElement('table');
            ownerTable.className = 'table table-striped';
            ownerTable.innerHTML = `
                <thead>
                    <tr>
                        <th>Owner</th>
                        <th>Total Score</th>
                    </tr>
                </thead>
                <tbody>
                    ${Object.entries(ownerStats)
                        .sort((a, b) => b[1].totalScore - a[1].totalScore)
                        .map(([owner, stats]) => `
                            <tr>
                                <td>${owner}</td>
                                <td>${stats.totalScore.toFixed(1)}</td>
                            </tr>
                        `).join('')}
                </tbody>
            `;
            
            // Create player scores table
            const playerTable = document.createElement('table');
            playerTable.className = 'table table-striped mt-4';
            playerTable.innerHTML = `
                <thead>
                    <tr>
                        <th>Player</th>
                        <th>Owner</th>
                        <th>Runs</th>
                        <th>Wickets</th>
                        <th>Catches</th>
                        <th>Run Outs</th>
                        <th>Score</th>
                    </tr>
                </thead>
                <tbody>
                    ${Object.entries(ownerStats)
                        .flatMap(([owner, stats]) => 
                            stats.players.map(player => `
                                <tr>
                                    <td>${player.name}</td>
                                    <td>${owner}</td>
                                    <td>${player.runs}</td>
                                    <td>${player.wickets}</td>
                                    <td>${player.catches}</td>
                                    <td>${player.run_outs}</td>
                                    <td>${player.score.toFixed(1)}${player.isHighestScorer ? ' *' : ''}</td>
                                </tr>
                            `)
                        ).join('')}
                </tbody>
            `;
            
            resultsDiv.appendChild(ownerTable);
            resultsDiv.appendChild(playerTable);
        }
    </script>
</body>
</html> 